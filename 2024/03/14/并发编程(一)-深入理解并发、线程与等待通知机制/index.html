<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>并发编程(一)-深入理解并发、线程与等待通知机制 | 萝卜的博客</title><meta name="author" content="Radish"><meta name="copyright" content="Radish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、基础概念1、进程和线程 进程是程序运行资源分配（以内存为主）的最小单位。  线程是 CPU 调度的最小单位。   大厂面试题：进程间的通信同一台计算机的进程通信称为 IPC（Inter-process communica），不同计算机之间的进程通信被称为 R(mote)PC，需要通过网络，并遵守共同的协议，比如大家熟悉的 Dubbo 就是一个 RPC 框架， 而 H协议也经常用在 RPC 上，">
<meta property="og:type" content="article">
<meta property="og:title" content="并发编程(一)-深入理解并发、线程与等待通知机制">
<meta property="og:url" content="http://example.com/2024/03/14/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%80)-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="萝卜的博客">
<meta property="og:description" content="一、基础概念1、进程和线程 进程是程序运行资源分配（以内存为主）的最小单位。  线程是 CPU 调度的最小单位。   大厂面试题：进程间的通信同一台计算机的进程通信称为 IPC（Inter-process communica），不同计算机之间的进程通信被称为 R(mote)PC，需要通过网络，并遵守共同的协议，比如大家熟悉的 Dubbo 就是一个 RPC 框架， 而 H协议也经常用在 RPC 上，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/touxiang.jpg">
<meta property="article:published_time" content="2024-03-14T15:05:00.000Z">
<meta property="article:modified_time" content="2024-03-24T15:51:44.527Z">
<meta property="article:author" content="Radish">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/touxiang.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/03/14/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%80)-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '并发编程(一)-深入理解并发、线程与等待通知机制',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-24 23:51:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li><li><a class="site-page child" href="/%E8%A7%86%E9%A2%91"><i class="fa-fw /movies/"></i><span> 1</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="萝卜的博客"><span class="site-name">萝卜的博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li><li><a class="site-page child" href="/%E8%A7%86%E9%A2%91"><i class="fa-fw /movies/"></i><span> 1</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">并发编程(一)-深入理解并发、线程与等待通知机制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-14T15:05:00.000Z" title="发表于 2024-03-14 23:05:00">2024-03-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-24T15:51:44.527Z" title="更新于 2024-03-24 23:51:44">2024-03-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%90%8E%E7%AB%AF/">Java后端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%90%8E%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="并发编程(一)-深入理解并发、线程与等待通知机制"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h1><h2 id="1、进程和线程"><a href="#1、进程和线程" class="headerlink" title="1、进程和线程"></a>1、进程和线程</h2><ul>
<li><p><strong>进程</strong>是程序运行资源分配（以内存为主）的最小单位。</p>
</li>
<li><p><strong>线程</strong>是 CPU 调度的最小单位。</p>
</li>
</ul>
<h3 id="大厂面试题：进程间的通信"><a href="#大厂面试题：进程间的通信" class="headerlink" title="大厂面试题：进程间的通信"></a>大厂面试题：进程间的通信</h3><p>同一台计算机的进程通信称为 IPC（Inter-process communica），不同计算机之间的进程通信被称为 R(mote)PC，需要通过网络，并遵守共同的协议，比如大家熟悉的 Dubbo 就是一个 RPC 框架， 而 H协议也经常用在 RPC 上， 比如 SpringCloud 微服务。 </p>
<p>大厂常见的面试题就是，进程间通信有几种方式？ </p>
<ol>
<li>管道， 分为匿名管道（pipe）及命名管道（named pipe）：匿名管道可用 于具有亲缘关系的父 子进程间的通信，命名管道除了具有管道所具有的功能外， 它还允许无亲缘关系进程间的通信。 </li>
<li>信号（signal）：信号是在软件层次上对中断机制的一种模拟，它是比较 复杂的通信方式， 用 于通知进程有某事件发生， 一个进程收到一个信号与处理器 收到一个中断请求效果上可以说是一致 的。 </li>
<li>消息队列（message queue）：消息队列是消息的链接表，它克服了上两 种通信方式中信号量有 限的缺点， 具有写权限得进程可以按照一定得规则向消息 队列中添加新信息；对消息队列有读权限 得进程则可以从消息队列中读取信息。   </li>
<li>共享内存（shared memory）：可以说这是最有用的进程间通信方式。它 使得多个进程可以访问 同一块内存空间， 不同进程可以及时看到对方进程中对共 享内存中数据得更新。这种方式需要依靠 某种同步操作， 如互斥锁和信号量等。 </li>
<li>信号量（semaphore）：主要作为进程之间及同一种进程的不同线程之间 得同步和互斥手段。 </li>
<li>套接字（socket）：这是一种更为一般得进程间通信机制， 它可用于网络 中不同机器之间的进 程间通信，应用非常广泛。同一机器中的进程还可以使用 Unix domain socket（比如同一机器中 MySQL 中的控制台 mysql shell 和 MySQL 服 务程序的连接），这种方式不需要经过网络协议栈， 不需要打包 拆包、计算校验 和、维护序号和应答等，比纯粹基于网络的进程间通信肯定效率更高。</li>
</ol>
<h2 id="2、上下文切换（Context-switch）"><a href="#2、上下文切换（Context-switch）" class="headerlink" title="2、上下文切换（Context switch）"></a>2、上下文切换（Context switch）</h2><p>既然操作系统要在多个进程（线程）之间进行调度， 而每个线程在使用 CPU 时总是要使用 CPU 中的资源，比如 CPU 寄存器和程序计数器。这就意味着，操作系统要保证线程在调度前后的正常执行，所以， 操作系统中就有上下文切换的概念，它是指 CPU(中央处理单元)从一个进程或线程到另一个进程或线程的切换。 </p>
<p>上下文是CPU 寄存器和程序计数器在任何时间点的内容。</p>
<p>寄存器是CPU内部的一小部分非常快的内存(相对于CPU内部的缓存和CPU外部较慢的RAM 主内存)，它通过提供对常用值的快速访问来加快计算机程序的执行。</p>
<p>程序计数器是一种专门的寄存器，它指示CPU在其指令序列中的位置，并保存着正在执行的指令的地址或下一条要执行的指令的地址，这取决于具体的系统。 </p>
<p>上下文切换可以更详细地描述为内核(即操作系统的核心)对 CPU 上的进程 (包括线程)执行以下活动:</p>
<ol>
<li>暂停一个进程的处理， 并将该进程的 CPU 状态(即上下文)存储在内存中的 某个地方</li>
<li>从内存中获取下一个进程的上下文，并在 CPU 的寄存器中恢复它   </li>
<li>返回到程序计数器指示的位置(即返回到进程被中断的代码行)以恢复进 程。 从数据来说， 以程序员的角度来看， 是方法调用过程中的各种局部的变量 与资源； 以线程的角 度来看， 是方法的调用栈中存储的各类信息。 引发上下文切换的原因一般包括： 线程、进程切换、系统调用等等。上下文 切换通常是计算密集 型的，因为涉及一系列数据在各种寄存器、 缓存中的来回 拷贝。就 CPU 时间而言， 一次上下文切 换大概需要 5000~20000 个时钟周期， 相 对一个简单指令几个乃至十几个左右的执行时钟周期， 可 以看出这个成本的巨大。</li>
</ol>
<h1 id="二、Java中的线程"><a href="#二、Java中的线程" class="headerlink" title="二、Java中的线程"></a>二、Java中的线程</h1><h2 id="1、Java程序天生就是多线程的"><a href="#1、Java程序天生就是多线程的" class="headerlink" title="1、Java程序天生就是多线程的"></a>1、Java程序天生就是多线程的</h2><p>一个 Java 程序从 main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与， 但实际上 Java 程序天生就是多线程程序， 因为执行 main() 方法的是一个名称为 main 的线程。 </p>
<p>而一个 Java 程序的运行就算是没有用户自己开启的线程，实际也有有很多 JVM 自行启动的线程， 一般来说有： </p>
<p>[6] Monitor Ctrl-Break //监控 Ctrl-Break 中断信号的 </p>
<p>[5] A内存 dump，线程 dump，类信息统计， 获取系统属性等 </p>
<p>[4] Signal Dispatcher // 分发处理发送给 JVM 信号的线程 </p>
<p>[3] Finalizer // 调用对象 ﬁﬁnalize 方法的线程 </p>
<p>[2] Reference Handler//清除 Reference 的线程 </p>
<p>[1] main //main 线程， 用户程序入口 尽管这些线程根据不同的 JDK 版本会有差异， 但是依然证明了 Java 程序天生就是多线程的。 </p>
<h2 id="2、线程的启动与中止"><a href="#2、线程的启动与中止" class="headerlink" title="2、线程的启动与中止"></a>2、线程的启动与中止</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>启动线程的方式有： </p>
<p>1、A extends Thread，然后A.start</p>
<p>2、A implements Runnable，然后交给Thread运行</p>
<p><strong>Thread 和 Runnable 的区别</strong></p>
<p>Thread 才是 Java 里对线程的唯一抽象，Runnable 只是对任务（业务逻辑） 的抽象。 Thread 可以接受任意一个 Runnable 的实例并执行。</p>
<p><strong>Callable 、Future 和 FutureTask</strong></p>
<p>Runnable 是一个接口， 在它里面只声明了一个 run()方法，由于 run()方法返回值为 void 类型， 所以在执行完任务之后无法返回任何结果。</p>
<p>Callable 位于 java.util.concurrent 包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call() ，这是一个泛型接口， call()函数返回的类型就是传递进来的 V 类型。</p>
<p>Future 就是对于具体的 Runnable 或者 Callable 任务的执行结果进行取消、查询是否完成、获取结 果。必要时可以通过 get 方法获取执行结果， 该方法会阻塞直到任务返回结果。 </p>
<p><img src="/../img/1710945436522.png" alt="1710945436522"></p>
<p>因为 Future 只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的 FutureTask。 </p>
<p><img src="/../img/1710945457299.png" alt="1710945457299"></p>
<p><img src="/../img/1710945467539.png" alt="1710945467539"></p>
<p>FutureTask 类实现了 RunnableFuture 接口，RunnableFuture 继承了 Runnable 接口和 Future 接口， 而 FutureTask 实现了 RunnableFuture 接口。所以它既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。</p>
<p>因此我们通过一个线程运行 Callable，但是 Thread 不支持构造方法中传递 Callable 的实例，所以我们需要通过 FutureTask 把一个 Callable 包装成 Runnable， 然后再通过这个 FutureTask 拿到 Callable 运行后的返回值。</p>
<h3 id="面试题：新启线程有几种方式？"><a href="#面试题：新启线程有几种方式？" class="headerlink" title="面试题：新启线程有几种方式？"></a>面试题：新启线程有几种方式？</h3><p>官方说法是在 Java 中有两种方式创建一个线程用以执行， 一种是派生自 Thread 类，另一种是实现 Runnable 接口。</p>
<p>当然本质上 Java 中实现线程只有一种方式， 都是通过 new Thread()创建线程对象，调用Thread#start 启动线程。</p>
<p>至于基于 callable 接口的方式，因为最终是要把实现了 callable 接口的对象 通过 FutureTask 包装成Runnable，再交给 Thread 去执行，所以这个其实可以和 实现 Runnable 接口看成同一类。</p>
<p>而线程池的方式， 本质上是池化技术，是资源的复用，和新启线程没什么关系。 所以，比较赞同官方的说法，有两种方式创建一个线程用以执行。 </p>
<h3 id="中止"><a href="#中止" class="headerlink" title="中止"></a>中止</h3><p>**线程自然终止 **</p>
<p>要么是 run 执行完成了，要么是抛出了一个未处理的异常导致线程提前结束。</p>
<p><strong>stop</strong></p>
<p>暂停、恢复和停止操作对应在线程 Thread 的 API 就是 suspend() 、resume() 和 stop()。但是这些 API 是过期的，也就是不建议使用的。不建议使用的原因主要有：以 suspend()方法为例，在调用后， 线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。 同样， stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会， 因此会导致程序可能工作在不确定状态下。正因为 suspend()、 resume()和 stop() 方法带来的副作用，这些方法才被标注为不建议使用的过期方法。 </p>
<p><strong>中断</strong></p>
<p>安全的中止则是其他线程通过调用某个线程 A 的 interrupt()方法对其进行中断操作, 中断好比其他线程对该线程打了个招呼，“A，你要中断了”，不代表线程 A 会立即停止自己的工作，同样的 A 线程完全可以不理会这种中断请求。</p>
<p>线程通过检查自身的中断标志位是否被置为 true 来进行响应，线程通过方法**isInterrupted()<strong>来进行判断是否被中断，也可以调用静态方法</strong>Thread.interrupted()**来进行判断当前线程是否被中断，不过 Thread.interrupted() 会同时将中断标识位改写为 false。</p>
<p>如果一个线程处于了阻塞状态（如线程调用了 thread.sleep 、thread.join、 thread.wait 等），则在线程在检查中断标示时如果发现中断标示为 true，则会在这些阻塞方法调用处抛出 InterruptedExcep异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为 false。</p>
<p><strong>不建议自定义一个取消标志位来中止线程的运行。</strong>因为 run 方法里有阻塞调用时会无法很快检测 到取消标志， 线程必须从阻塞调用返回后， 才会检查这个取消标志。这种情况下，使用中断会更好，因为， </p>
<p>一、一般的阻塞方法，如 sleep 等本身就支持中断的检查， </p>
<p>二、检查中断位的状态和检查取消标志位没什么区别， 用中断位的状态还可以避免声明取消标志位，减少资源的消耗。</p>
<p><strong>注意：处于死锁状态的线程无法被中断</strong> </p>
<h3 id="深入理解run-和start"><a href="#深入理解run-和start" class="headerlink" title="深入理解run()和start()"></a>深入理解run()和start()</h3><p>Thread 类是Java 里对线程概念的抽象，可以这样理解：我们通过 new Thread() 其实只是 new 出一 个 Thread 的实例，还没有操作系统中真正的线程挂起钩来。 只有执行了 start()方法后，才实现了真 正意义上的启动线程。</p>
<p>从 Thread 的源码可以看到， Thread 的 start 方法中调用了 start0()方法，而 start0()是个 native方法， 这就说明 Thread#start 一定和操作系统是密切相关的。</p>
<p>start()方法让一个线程进入就绪队列等待分配 cpu，分到 cpu 后才调用实现的 run()方法，start()方法不能重复调用，如果重复调用会抛出异常（注意， 此处可能有面试题：多次调用一个线程的 start 方法会怎么样？ ）。</p>
<p>而 run 方法是业务逻辑实现的地方， 本质上和任意一个类的任意一个成员方法并没有任何区别， 可以重复执行，也可以被单独调用。 </p>
<h3 id="线程的状态-x2F-生命周期"><a href="#线程的状态-x2F-生命周期" class="headerlink" title="线程的状态/生命周期"></a>线程的状态/生命周期</h3><p>Java 中线程的状态分为 6 种： </p>
<ol>
<li>初始(NEW)：新创建了一个线程对象，但还没有调用 start()方法。 </li>
<li>运行(RUNNABLE)：Java 线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。 线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start()方法。 该状态的线程位于可运行线程池中， 等待被线程调度选中， 获取 CPU 的使用权， 此时处于就绪状态（ready）。就绪状态的线程在获得 CPU 时间片后变为运行中状态（running）。 </li>
<li>阻塞(BLOCKED)：表示线程阻塞于锁。 </li>
<li>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作 （通知或中断）。 </li>
<li>超时等待(TIMED_WAITING)：该状态不同于 WAITING，它可以在指定的时间后自行返回。</li>
<li>终止(TERMINATED)：表示该线程已经执行完毕。</li>
</ol>
<p>状态之间的变迁如下图所示</p>
<p><img src="/../img/1711025394271.png" alt="1711025394271"></p>
<p>掌握这些状态可以让我们在进行 Java 程序调优时可以提供很大的帮助</p>
<h3 id="其他的线程相关方法"><a href="#其他的线程相关方法" class="headerlink" title="其他的线程相关方法"></a>其他的线程相关方法</h3><p>yield()方法：使当前线程让出 CPU 占有权， 但让出的时间是不可设定的。也不会释放锁资源。同时执行 yield()的线程有可能在进入到就绪状态后会被操作系统再次选中马上又被执行。</p>
<p>比如，ConcurrentHashMap#initTable 方法中就使用了这个方法，</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() {</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是因为 ConcurrentHashMap 中可能被多个线程同时初始化 table，但是其实这个时候只允许一个线程进行初始化操作， 其他的线程就需要被阻塞或等待， 但是初始化操作其实很快， 这里 DougLea 大师为了避免阻塞或者等待这些操作引发的上下文切换等等开销， 就让其他不执行初始化操作的线程干脆执行 yield() 方法，以让出 CPU 执行权，让执行初始化操作的线程可以更快的执行完成。</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>在 Java 线程中， 通过一个整型成员变量 priority 来控制优先级， 优先级的范围从 1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是 5，优先级高的线程分配时间片的数量要多于优先级低的线程。</p>
<p>设置线程优先级时， 针对频繁阻塞（休眠或者 I/O 操作） 的线程需要设置较高优先级，而偏重计算（需要较多 CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。在不同的 JVM 以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定。</p>
<h3 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h3><p>线程调度是指系统为线程分配 CPU 使用权的过程，主要调度方式有两种：<strong>协同式线程调度</strong>和<strong>抢占式线程调度</strong>。</p>
<p>使用协同式线程调度的多线程系统，线程执行的时间由线程本身来控制，线程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上。使用协同式线程调度的最大好处是实现简单，由于线程要把自己的事情做完后才会通知系统进行线程切换， 所以没有线程同步的问题， 但是坏处也很明显， 如果一个线程出了问题，则程序就会一直阻塞。</p>
<p>使用抢占式线程调度的多线程系统， 每个线程执行的时间以及是否切换都由系统决定。在这种情况下，线程的执行时间不可控，所以不会有「一个线程导致整个进程阻塞」的问题出现。</p>
<p>Java 线程调度就是抢占式调度。</p>
<p>在 Java 中，Thread.yield()可以让出CPU执行时间，但是对于获取执行时间，线程本身是没有办法的。对于获取 CPU 执行时间，线程唯一可以使用的手段是设置线程优先级， Java设置了10个级别的程序优先级，当两个线程同时处于 Ready 状态时，优先级越高的线程越容易被系统选择执行。</p>
<h3 id="线程和协程"><a href="#线程和协程" class="headerlink" title="线程和协程"></a>线程和协程</h3><p>为什么 Java 线程调度是抢占式调度？这需要我们了解 Java 中线程的实现模式。</p>
<p>我们已经知道线程其实是操作系统层面的实体， Java 中的线程怎么和操作系统层面对应起来呢？</p>
<p>任何语言实现线程主要有三种方式：使用内核线程实现（1:1 实现)，使用用户线程实现(1:N 实现），使用用户线程加轻量级进程混合实现(N:M 实现）。</p>
<h4 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h4><p>使用内核线程实现的方式也被称为 1： 1 实现。 内核线程（Kernel-Level Thread ， KLT） 就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler） 对线程进行调度，并负责将线程的任务映射到各个处理器上。</p>
<p>由于内核线程的支持， 每个线程都成为一个独立的调度单元， 即使其中某一个在系统调用中被阻塞了， 也不会影响整个进程继续工作，相关的调度工作也不需要额外考虑，已经由操作系统处理了。</p>
<p>局限性：首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高， 需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。其次，每个语言层面的线程都需要有一个内核线程的支持， 因此要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持的线程数量是有限的。</p>
<h4 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h4><p>严格意义上的用户线程指的是完全建立在用户空间的线程库上， 系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成， 不需要内核的帮助。 如果程序实现得当，这种线程不需要切换到内核态， 因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量， 部分高性能数据库中的多线程就是由用户线程实现的。</p>
<p>用户线程的优势在于不需要系统内核支援， 劣势也在于没有系统内核的支援， 所有的线程操作都需要由用户程序自己去处理。线程的创建、销毁、切换和调度 都是用户必须考虑的问题， 而且由于操作系统只把处理器资源分配到进程， 那诸如“阻塞如何处理”“多处理器系统中如何将线程映射到其他处理器上”这类问 题解决起来将会异常困难， 甚至有些是不可能实现的。 因为使用用户线程实现的程序通常都比较复杂， 所以一般的应用程序都不倾向使用用户线程。Java 语言曾经使用过用户线程，最终又放弃了。 但是近年来许多新的、以高并发为卖点的编程语言又普遍支持了用户线程，譬如 Golang。</p>
<h4 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h4><p>线程除了依赖内核线程实现和完全由用户程序自己实现之外， 还有一种将内核线程与用户线程一起使用的实现方式， 被称为 N：M 实现。 在这种混合实现下， 既存在用户线程， 也存在内核线程。</p>
<p>用户线程还是完全建立在用户空间中， 因此用户线程的创建、 切换、 析构等操作依然廉价， 并且可以支持大规模的用户线程并发。</p>
<p>同样又可以使用内核提供的线程调度功能及处理器映射， 并且用户线程的系统调用要通过内核线程来完成。在这种混合模式中， 用户线程与轻量级进程的数量比是不定的，是 N：M 的关系。</p>
<h4 id="Java-线程的实现"><a href="#Java-线程的实现" class="headerlink" title="Java 线程的实现"></a>Java 线程的实现</h4><p>Java 线程在早期的 Classic 虚拟机上（JDK 1.2 以前），是用户线程实现的， 但从 JDK 1.3 起， 主流商用 Java 虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现，即采用 1： 1 的线程模型。</p>
<p>以 HotSpot 为例，它的每一个 Java 线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构， 所以 HotSpot 自己是不会去干涉线程调度的，全权交给底下的操作系统去处理。</p>
<p>所以，这就是我们说 Java 线程调度是抢占式调度的原因。而且 Java 中的线程优先级是通过映射到操作系统的原生线程上实现的， 所以线程的调度最终取决于操作系统，操作系统中线程的优先级有时并不能和 Java 中的一一对应，所以 Java 优先级并不是特别靠谱。</p>
<h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p><strong>出现的原因</strong></p>
<p>随着互联网行业的发展，目前内核线程实现在很多场景已经有点不适宜了。 比如，互联网服务架构在处理一次对外部业务请求的响应， 往往需要分布在不同机器上的大量服务共同协作来实现，也就是我们常说的微服务， 这种服务细分的架构在减少单个服务复杂度、 增加复用性的同时， 也不可避免地增加了服务的数量， 缩短了留给每个服务的响应时间。这要求每一个服务都必须在极短的时间内完成计算， 这样组合多个服务的总耗时才不会太长；也要求每一个服务提供者都要能同时处理数量更庞大的请求， 这样才不会出现请求由于某个服务被阻塞而出现等待。</p>
<p>Java 目前的并发编程机制就与上述架构趋势产生了一些矛盾， 1：1 的内核线程模型是如今 Java虚拟机线程实现的主流选择， 但是这种映射到操作系统上的线程天然的缺陷是切换、调度成本高昂， 系统能容纳的线程数量也很有限。 以前处理一个请求可以允许花费很长时间在单体应用中，具有这种线程切换的成本也是无伤大雅的， 但现在在每个请求本身的执行时间变得很短、 数量变得很多的前提下， 用户本身的业务线程切换的开销甚至可能会接近用于计算本身的开销， 这就会造成严重的浪费。</p>
<p>另外我们常见的 Java Web 服务器，比如 Tomcat 的线程池的容量通常在几十个到两百之间， 当把数以百万计的请求往线程池里面灌时， 系统即使能处理得过来，但其中的切换损耗也是相当可观的。</p>
<p>这样的话，对 Java 语言来说，用户线程的重新引入成为了解决上述问题一个非常可行的方案。</p>
<p>其次， Go 语言等支持用户线程等新型语言给 Java 带来了巨大的压力， 也使得 Java 引入用户线程成为了一个绕不开的话题。</p>
<p><strong>协程简介</strong></p>
<p>为什么用户线程又被称为协程呢？我们知道， 内核线程的切换开销是来自于保护和恢复现场的成本， 那如果改为采用用户线程， 这部分开销就能够省略掉吗？ 答案还是“不能”。 但是， 一旦把保护、恢复现场及调度的工作从操作系统交到程序员手上， 则可以通过很多手段来缩减这些开销。</p>
<p>由于最初多数的用户线程是被设计成协同式调度（Coopera） 的，所以它有了一个别名—— “协程”（Corou） 完整地做调用栈的保护、 恢复工作，所以今天也被称为“有栈协程”（Stackfull Corou）。</p>
<p>协程的主要优势是轻量，无论是有栈协程还是无栈协程， 都要比传统内核线程要轻量得多。如果进行量化的话， 那么如果不显式设置，则在 64 位 Linux 上 HotSpot 的线程栈容量默认是 1MB ，此外内核数据结构（Kernel Data Structures） 还会额外消耗 16KB 内存。与之相对的， 一个协程的栈通常在几百个字节到几KB之间， 所以Java 虚拟机里线程池容量达到两百就已经不算小了， 而很多支持协程的应用中， 同时并存的协程数量可数以十万计。</p>
<p>协程当然也有它的局限， 需要在应用层面实现的内容（调用栈、 调度器这些）特别多，同时因为协程基本上是协同式调度，则协同式调度的缺点自然在协程上也存在。</p>
<p>总的来说，协程机制适用于被阻塞的，且需要大量并发的场景（网络 io）， 不适合大量计算的场景，因为协程提供规模(更高的吞吐量)，而不是速度(更低的延迟)。</p>
<p><strong>纤程-Java中的协程</strong></p>
<p>在 JVM 的实现上，以 HotSpot 为例，协程的实现会有些额外的限制， Java调用栈跟本地调用栈是做在一起的。 如果在协程中调用了本地方法， 还能否正常切换协程而不影响整个线程？ 另外，如果协程中遇传统的线程同步措施会怎样？ 譬如 Kotlin 提供的协程实现， 一旦遭遇 synchronize 关键字， 那挂起来的仍将是整个线程。</p>
<p>所以 Java 开发组就 Java 中协程的实现也做了很多努力， OpenJDK 在 2018 年 创建了 Loom 项目，这是 Java 的官方解决方案， 并用了“纤程（Fiber） ”这个 名字。</p>
<p>Loom 项目背后的意图是重新提供对用户线程的支持， 但这些新功能不是为了取代当前基于操作系统的线程实现， 而是会有两个并发编程模型在 Java 虚拟机中并存， 可以在程序中同时使用。 新模型有意地保持了与目前线程模型相似的 API 设计， 它们甚至可以拥有一个共同的基类， 这样现有的代码就不需要为了使用纤程而进行过多改动， 甚至不需要知道背后采用了哪个并发编程模型。</p>
<p>根据 Loom 团队在 2018 年公布的他们对 Jetty 基于纤程改造后的测试结果， 同样在 5000QPS 的压力下， 以容量为 400 的线程池的传统模式和每个请求配以一个纤程的新并发处理模式进行对比，前者的请求响应延迟在 10000 至 20000 毫秒之间， 而后者的延迟普遍在 200 毫秒以下，</p>
<p>目前 Java 中比较出名的协程库是 Quasar[ˈkweɪzɑː(r)]（Loom 项目的 Leader 就 是 Quasar 的作者Ron Pressler）， Quasar 的实现原理是字节码注入，在字节码 层面对当前被调用函数中的所有局部变量进行保存和恢复。这种不依赖 Java 虚拟机的现场保护虽然能够工作，但影响性能。</p>
<p><strong>Quasar 实战</strong></p>
<p>本实战的代码是单独的项目 quasar。</p>
<p>Quasar 的使用其实并不复杂，首先引入 Maven 依赖</p>
<p><img src="/../img/1711030416642.png" alt="1711030416642"></p>
<p>在具体的业务场景上， 我们模拟调用某个远程的服务， 假设远程服务处理耗时需要 1S，使用休眠 1S 来代替。为了比较， 用多线程和协程分别调用这个服务 10000 次，来看看两者所需的耗时。</p>
<p>Quasar 的：</p>
<p><img src="/../img/1711030902819.png" alt="1711030902819"></p>
<p>线程的：</p>
<p><img src="/../img/1711030922079.png" alt="1711030922079"></p>
<p>从代码层面来看， 两者的代码高度相似， 忽略两者的公共部分， 代码不同的 地方也就 2 、3行</p>
<p>其中的 Fiber 就是 Quasar 为我们提供的协程相关的类，可以类比为 Java 中 的 Thread 类。</p>
<p>其他的 CountDownLatch（闭锁，线程的某种协调工具类）、Executors.newCachedThreadPool（线程池） 是并发编程后面的课程将要学习的知识。StopWatch 是Spring 的一个工具类， 一个简单的秒表工具， 可以计时指定代码段的运行时间以及汇总这个运行时间。</p>
<p>在执行 Quasar 的代码前，还需要配置 VM 参数（Quasar 的实现原理是字节 码注入，所以，在运行应用前，需要配置好 quasar-core 的 java agent 地址）</p>
<p>-javaagent:D:\Maven\repository\co\paralleluniverse\quasar-core\0.7.9\quasar- core-0.7.9.jar</p>
<p>自己运行前记得修改为本机的 Maven 仓库路径</p>
<p><img src="/../img/1711031083944.png" alt="1711031083944"></p>
<p>看看执行的结果：</p>
<p><img src="/../img/1711031221272.png" alt="1711031221272"></p>
<p><img src="/../img/1711031230101.png" alt="1711031230101"></p>
<p>可以看到性能的提升还是非常明显的。而且上面多线程编程时， 并没有指定 线程池的大小， 在实际开发中是绝不允许的。一般我们会设置一个固定大小的线 程池， 因为线程资源是宝贵， 线程多了费内存还会带来线程切换的开销。上面的 场景在设置 200 个固定大小线程池时</p>
<p>（Executors.newFixedThreadPool(200)），在 本机的测试结果达到了 50 多秒，几乎是数量级的增加。</p>
<p>由这个结果也可以看到协程在需要处理大量 IO 的情况下非常具有优势， 基 于固定的几个线程调度， 可以轻松实现百万级的协程处理， 而且内存消耗非常平 稳。</p>
<p>更多 Quasar 的使用方法和技巧，请大家自行挖掘和学习。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>Daemon（守护） 线程是一种支持型线程，因为它主要被用作程序中后台调 度以及支持性工作。这意味着，当一个 Java 虚拟机中不存在非 Daemon 线程的 时候， Java 虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置 为 Daemon 线程。我们一般用不上，比如垃圾回收线程就是Daemon 线程。</p>
<p>Daemon 线程被用作完成支持性工作， 但是在 Java 虚拟机退出时 Daemon 线程中的 ﬁnally 块并不一定会执行。在构建 Daemon 线程时， 不能依靠 ﬁnally 块中的内容来确保执行关闭或清理资源的逻辑。</p>
<h2 id="3、线程间的通信和协调、-协作"><a href="#3、线程间的通信和协调、-协作" class="headerlink" title="3、线程间的通信和协调、 协作"></a>3、线程间的通信和协调、 协作</h2><p>很多的时候， 孤零零的一个线程工作并没有什么太多用处， 更多的时候， 我们是很多线程一起工作，而且是这些线程间进行通信， 或者配合着完成某项工作， 这就离不开线程间的通信和协调、协作。</p>
<h3 id="管道输入输出流"><a href="#管道输入输出流" class="headerlink" title="管道输入输出流"></a>管道输入输出流</h3><p>我们已经知道，进程间有好几种通信机制，其中包括了管道，其实 Java 的线程里也有类似的管道机制， 用于线程之间的数据传输， 而传输的媒介为内存。</p>
<p>设想这么一个应用场景：通过 Java 应用生成文件， 然后需要将文件上传到云端，比如：</p>
<p>1 、页面点击导出后， 后台触发导出任务， 然后将 mysql 中的数据根据导出条件查询出来， 生成 Excel 文件， 然后将文件上传到 oss，最后发布一个下载文件的链接。</p>
<p>2、和银行以及金融机构对接时，从本地某个数据源查询数据后， 上报 xml 格式的数据，给到指定的 、或是 oss 的某个目录下也是类似的。</p>
<p>我们一般的做法是， 先将文件写入到本地磁盘， 然后从文件磁盘读出来上传到云盘，但是通过Java中的管道输入输出流一步到位，则可以避免写入磁盘这 一步。</p>
<p>Java 中的管道输入/输出流主要包括了如下 4 种具体实现：</p>
<p>PipedOutputStream 、PipedInputStream 、PipedReader 和 PipedWriter，前两种面向字节，而后两种面向字符。</p>
<p>示例代码可参见 cn.tulingxueyuan.base.Piped</p>
<h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join 方法"></a>join 方法</h3><p><strong>面试题</strong></p>
<p>现在有 T1、T2、T3 三个线程， 你怎样保证 T2 在 T1 执行完后执行， T3 在 T2 执行完后执行？答：用 Thread#join 方法即可， 在 T3 中调用 T2.join，在 T2 中调用 T1.join。</p>
<p><strong>join()</strong></p>
<p>把指定的线程加入到当前线程， 可以将两个交替执行的线程合并为顺序执行。 比如在线程 B 中调用了线程 A 的 Join()方法， 直到线程 A 执行完毕后， 才会继续 执行线程 B 剩下的代码。</p>
<h3 id="synchronized-内置锁"><a href="#synchronized-内置锁" class="headerlink" title="synchronized 内置锁"></a>synchronized 内置锁</h3><p>线程开始运行， 拥有自己的栈空间， 就如同一个脚本一样， 按照既定的代码一步一步地执行，直到终止。但是， 每个运行中的线程， 如果仅仅是孤立地运行， 那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作， 包括数据之间的共享，协同处理事情。这将会带来巨大的价值。</p>
<p>Java 支持多个线程同时访问一个对象或者对象的成员变量，但是多个线程同时访问同一个变量，会导致不可预料的结果。关键字 synchronized 可以修饰方法或者以同步块的形式来进行使用， 它主要确保多个线程在同一个时刻， 只能有一个线程处于方法或者同步块中， 它保证了线程对变量访问的可见性和排他性， 使多个线程访问同一个变量的结果正确，它又称为内置锁机制。</p>
<h3 id="对象锁和类锁"><a href="#对象锁和类锁" class="headerlink" title="对象锁和类锁"></a>对象锁和类锁</h3><p>对象锁是用于对象实例方法， 或者一个对象实例上的， 类锁是用于类的静态方法或者一个类的class 对象上的。</p>
<p><img src="/../img/1711033405185.png" alt="1711033405185"></p>
<p>比如上面的 synClass 方法就使用了类锁。</p>
<p>我们知道， 类的对象实例可以有很多个， 所以当对同一个变量操作时， 用来做锁的对象必须是同一个，否则加锁毫无作用。 比如下面的示例代码：	</p>
<p><img src="/../img/1711033456012.png" alt="1711033456012"></p>
<p>但是有一点必须注意的是， 其实类锁只是一个概念上的东西， 并不是真实存在的，类锁其实锁的是每个类的对应的 class 对象，但是每个类只有一个 class 对象，所以每个类只有一个类锁。</p>
<p>同样的，当对同一个变量操作时，类锁和对象（非 class 对象）锁混用也同样毫无用处。</p>
<h3 id="错误的加锁和原因分析"><a href="#错误的加锁和原因分析" class="headerlink" title="错误的加锁和原因分析"></a>错误的加锁和原因分析</h3><p>参见代码 TestIntegerSyn，执行结果</p>
<p><img src="/../img/1711034042351.png" alt="1711034042351"></p>
<p>可以看到 i 的取值会出现乱序或者重复取值的现象</p>
<p>原因：虽然我们对 i 进行了加锁，但是</p>
<p><img src="/../img/1711034139657.png" alt="1711034139657"></p>
<p>但是当我们反编译这个类的 class 文件后，可以看到 i++实际是，</p>
<p><img src="/../img/1711034171549.png" alt="1711034171549"></p>
<p><img src="/../img/1711034180334.png" alt="1711034180334"></p>
<p>本质上是返回了一个新的 Integer 对象。也就是每个线程实际加锁的是不同的 Integer 对象，所以说到底， 还是当对同一个变量操作时， 用来做锁的对象必须是同一个，否则加锁毫无作用。</p>
<h3 id="volatile，最轻量的通信-x2F-同步机制"><a href="#volatile，最轻量的通信-x2F-同步机制" class="headerlink" title="volatile，最轻量的通信/同步机制"></a>volatile，最轻量的通信/同步机制</h3><p>volatile保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>不加 volatile 时，子线程无法感知主线程修改了 ready 的值，从而不会退出循环， 而加了 volatile 后，子线程可以感知主线程修改了 ready 的值，迅速退出循环。</p>
<p>但是 volatile 不能保证数据在多个线程下同时写时的线程安全，vola最适用的场景：一个线程写，多个线程读。</p>
<h2 id="4、等待-x2F-通知机制"><a href="#4、等待-x2F-通知机制" class="headerlink" title="4、等待/通知机制"></a>4、等待/通知机制</h2><p>线程之间相互配合，完成某项工作，比如： 一个线程修改了一个对象的值， 而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程， 而最终执行又是另一个线程。前者是生产者， 后者就是消费者， 这种模式隔离了 “做什么”（what）和“怎么做”（How），简单的办法是让消费者线程不断地 循环检查变量是否符合预期在 while 循环中设置不满足的条件， 如果条件满足则退出 while 循环，从而完成消费者的工作。却存在如下问题：</p>
<p>1）难以确保及时性。</p>
<p>2）难以降低开销。如果降低睡眠的时间，比如休眠 1 毫秒，这样消费者能更加迅速地发现条件变化， 但是却可能消耗更多的处理器资源， 造成了无端的浪费。</p>
<p>等待/通知机制则可以很好的避免，这种机制是指一个线程 A 调用了对象 O 的 wait()方法进入等待状态，而另一个线程 B 调用了对象 O 的 notify()或者notifyAll()方法， 线程 A 收到通知后从对象 O 的 wait()方法返回， 进而执行后续操作。上述两个线程通过对象 O 来完成交互， 而对象上的 wait()和 notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。</p>
<p>notify()：</p>
<p>通知一个在对象上等待的线程,使其从 wait 方法返回,而返回的前提是该线程获取到了对象的锁，没有获得锁的线程重新进入 WAITING 状态。</p>
<p>notifyAll()：</p>
<p>通知所有等待在该对象上的线程</p>
<p>wait()</p>
<p>调用该方法的线程进入 WAITING 状态, 只有等待另外线程的通知或被中断 才会返回 需要注意,调用wait()方法后,会释放对象的锁</p>
<p>wait(long)</p>
<p>超时等待一段时间,这里的参数时间是毫秒,也就是等待长达 n 毫秒,如果没有通知就超时返回</p>
<p>wait (long,int)</p>
<p>对于超时时间更细粒度的控制,可以达到纳秒</p>
<h3 id="等待和通知的标准范式"><a href="#等待和通知的标准范式" class="headerlink" title="等待和通知的标准范式"></a>等待和通知的标准范式</h3><p>等待方遵循如下原则。</p>
<p>1）获取对象的锁。</p>
<p>2）如果条件不满足， 那么调用对象的 wait()方法， 被通知后仍要检查条件。 </p>
<p>3）条件满足则执行对应的逻辑。</p>
<p><img src="/../img/image30.jpeg" alt="image30"></p>
<p>通知方遵循如下原则。</p>
<p>1）获得对象的锁。</p>
<p>2）改变条件。</p>
<p>3）通知所有等待在对象上的线程。</p>
<p><img src="/../img/image31.jpeg" alt="image31"></p>
<p>在调用 <strong>wait</strong>（） 、**notify()<strong>系列方法之前， 线程必须要获得该对象的对象级别锁， 即只能在同步方法或同步块中调用 <strong>wait</strong>（）方法、</strong>notify()**系列方法，进入 wait（） 方法后， 当前线程释放锁，在从 wait（） 返回前， 线程与其他线程竞争重新获得锁，执行 notify()系列方法的线程退出调用了 notifyAll 的 synchronized  代码块的时候后，他们就会去竞争。如果其中一个线程获得了该对象锁， 它就会继续往下执行， 在它退出 synchronized 代码块，释放锁后， 其他的已经被唤醒的线程将会继续竞争获取该锁， 一直进行下去， 直到所有被唤醒的线程都执行完毕。</p>
<p><strong>notify 和 notifyAll 应该用谁</strong></p>
<p>尽可能用 notifyall()，谨慎使用 notify() ，因为 notify()只会唤醒一个线程， 我们无法确保被唤醒的这个线程一定就是我们需要唤醒的线程</p>
<p><strong>等待超时模式实现一个连接池</strong></p>
<p>调用场景：调用一个方法时等待一段时间（一般来说是给定一个时间段）， 如果该方法能够在给定的时间段之内得到结果， 那么将结果立刻返回，反之，超时返回默认结果。</p>
<p>假设等待时间段是 T，那么可以推断出在当前时间 now+T 之后就会超时等待持续时间： REMAINING=T。</p>
<p>• 超时时间： FUTURE=now+T。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对当前对象加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException { </span><br><span class="line">    <span class="type">long</span> <span class="variable">future</span> <span class="operator">=</span> System.currentTimeMillis() + mills;</span><br><span class="line">	<span class="type">long</span> <span class="variable">remaining</span> <span class="operator">=</span> mills;</span><br><span class="line">	<span class="comment">// 当超时大于 0 并且 result 返回值不满足要求</span></span><br><span class="line">	<span class="keyword">while</span> ((result == <span class="literal">null</span>) &amp;&amp; remaining &gt; <span class="number">0</span>) {</span><br><span class="line">		wait(remaining);</span><br><span class="line">		remaining = future - System.currentTimeMillis();</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>具体实现参见：包 cn.tulingxueyuan.base.pool 下的代码</p>
<p>客户端获取连接的过程被设定为等待超时的模式，也就是在 1000 毫秒内如果无法获取到可用连接，将会返回给客户端一个 null。设定连接池的大小为 10 个，然后通过调节客户端的线程数来模拟无法获取连接的场景。</p>
<p>它通过构造函数初始化连接的最大上限，通过一个双向队列来维护连接，调用方需要先调用fetchConnection(long)方法来指定在多少毫秒内超时获取连接，当连接使用完成后，需要调用releaseConnection(Connection)方法将连接放回线程池。</p>
<p><strong>面试题</strong></p>
<p><strong>方法和锁</strong></p>
<p>调用 yield()  、sleep() 、wait() 、notify()等方法对锁有何影响？  yield()  、sleep()被调用后，都不会释放当前线程所持有的锁。</p>
<p>调用 wait()方法后，会释放当前线程持有的锁，而且当前被唤醒后， 会重新去竞争锁，锁竞争到后才会执行 wait 方法后面的代码。</p>
<p>调用 notify() 系列方法后， 对锁无影响， 线程只有在 syn  同步代码执行完后才会自然而然的释放锁，所以 notify()系列方法一般都是 syn 同步代码的最后一行。</p>
<p><strong>wait 和 notify</strong></p>
<p><strong>为什么</strong> <strong>wait</strong> <strong>和</strong> <strong>notify</strong> <strong>方法要在同步块中调用？</strong></p>
<p><strong>原因</strong></p>
<p>主要是因为 Java API 强制要求这样做，如果你不这么做，你的代码会抛出 IllegalMonitorStateException 异常。 其实真实原因是：</p>
<p>这个问题并不是说只在 Java 语言中会出现，而是会在所有的多线程环境下出现。</p>
<p>假如我们有两个线程， 一个消费者线程， 一个生产者线程。生产者线程的任务可以简化成将 count 加一，而后唤醒消费者； 消费者则是将 count 减一，而后在减到 0 的时候陷入睡眠：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">生产者伪代码：</span><br><span class="line">count+1;</span><br><span class="line">notify();</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">消费者伪代码：</span><br><span class="line">while(count&lt;=0)</span><br><span class="line">wait()</span><br><span class="line">count--</span><br></pre></td></tr></tbody></table></figure>

<p>这里面有问题。什么问题呢？</p>
<p>生产者是两个步骤：</p>
<ol>
<li><p>count+1;</p>
</li>
<li><p>notify();</p>
</li>
</ol>
<p>消费者也是两个步骤：</p>
<ol>
<li><p>检查 count 值；</p>
</li>
<li><p>睡眠或者减一；</p>
</li>
</ol>
<p>万一这些步骤混杂在一起呢？比如说，初始的时候 count 等于 0，这个时候 消费者检查 count 的值，发现 count 小于等于 0 的条件成立； 就在这个时候， 发 生了上下文切换，生产者进来了，噼噼啪啪一顿操作，把两个步骤都执行完了， 也就是发出了通知， 准备唤醒一个线程。这个时候消费者刚决定睡觉， 还没睡呢，  所以这个通知就会被丢掉。紧接着，消费者就睡过去了……</p>
<p><img src="/../img/image32.png" alt="image32"></p>
<p>这就是所谓的 lost wake up  问题。</p>
<p><strong>那么怎么解决这个问题呢？</strong></p>
<p>现在我们应该就能够看到，问题的根源在于，消费者在检查 count 到调用 wait()之间， count 就可能被改掉了。</p>
<p>这就是一种很常见的竞态条件。</p>
<p>很自然的想法是， 让消费者和生产者竞争一把锁， 竞争到了的， 才能够修改 count 的值。</p>
<p><strong>为什么你应该在循环中检查等待条件?</strong></p>
<p>处于等待状态的线程可能会收到错误警报和伪唤醒， 如果不在循环中检查等待条件， 程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用 wait()方法效果更好的原因。</p>
<p><strong>CompleteableFuture</strong></p>
<p>Java 的 1.5  版本引入了 Future，可以把它简单的理解为运算结果的占位符，它提供了两个方法来获取运算结果。</p>
<p>get()：调用该方法线程将会无限期等待运算结果。</p>
<p>get(longtimeout, TimeUnit unit)：调用该方法线程将仅在指定时间 timeout 内等待结果，如果等待超时就会抛出 TimeoutException  异常。</p>
<p>Future  可以使用 Runnable  或 Callable   实例来完成提交的任务，它存在如下几个问题：</p>
<p>阻塞调用 get()  方法会一直阻塞，直到等待直到计算完成，它没有提供任何方法可以在完成时通知， 同时也不具有附加回调函数的功能。</p>
<p>链式调用和结果聚合处理在很多时候我们想链接多个 Future  来完成耗时 较长的计算， 此时需要合并结果并将结果发送到另一个任务中， 该接口很难完成 这种处理。</p>
<p>异常处理 Future  没有提供任何异常处理的方式。</p>
<p>JDK1.8 才新加入的一个实现类 CompletableFuture ，很好的解决了这些问题， CompletableFuture 实现了 Future ， CompletionStage两个接口。 实现了</p>
<p>Future 接口，意味着可以像以前一样通过阻塞或者轮询的方式获得结果。</p>
<p><strong>创建</strong></p>
<p>除了直接 new 出一个 CompletableFuture 的实例，还可以通过工厂方法创建 CompletableFuture 的实例</p>
<p>工厂方法：</p>
<p><img src="/../img/image33.jpeg" alt="image33"></p>
<p><img src="/../img/image34.png" alt="image34"></p>
<p>Asynsc 表示异步,而 supplyAsync 与 runAsync 不同在于， supplyAsync 异步返回一个结果,runAsync 是 void 。第二个函数第二个参数表示是用我们自己创建的线程池,否则采用默认的 ForkJoinPool.commonPool()作为它的线程池。</p>
<p>获得结果的方法</p>
<p>public T get()</p>
<p>public T get(longtimeout, TimeUnit unit)</p>
<p>public T getNow(T valueIfAbsent)</p>
<p>public T join()</p>
<p>getNow 有点特殊，如果结果已经计算完则返回结果或者抛出异常，否则返回给定的 valueIfAbsent 值。</p>
<p>join 返回计算的结果或者抛出一个 unchecked 异常(CompletionException)，它和 get 对抛出的异常的处理有些细微的区别。</p>
<p>辅助方法</p>
<p>public static CompletableFuture allOf(CompletableFuture… cfs)</p>
<p>public static CompletableFuture anyOf(CompletableFuture… cfs) allOf 方法是当所有的 CompletableFuture 都执行完后执行计算。</p>
<p>anyOf 方法是当任意一个 CompletableFuture 执行完后就会执行计算， 计算的结果相同。</p>
<p>CompletionStage 是一个接口，从命名上看得知是一个完成的阶段， 它代表了一个特定的计算的阶段， 可以同步或者异步的被完成。</p>
<p>你可以把它看成一个计算流水线上的一个单元， 并最终会产生一个最终结果，这意味着几个CompletionStage 可以串联起来，一个完成的阶段可以触发下一阶段的执行，接着触发下一次， 再接着触发下一次，……… .。</p>
<p>总结 CompletableFuture 几个关键点：<br>1、计算可以由 Future  ，Consumer   或者 Runnable  接口中的 apply，accept 或者 run 等方法表示。<br>2 、计算的执行主要有以下<br>a.  默认执行<br>b.  使用默认的 CompletionStage  的异步执行提供者异步执行。这些方法名使 用 someActionAsync 这种格式表示。<br>c.  使用 Executor  提供者异步执行。这些方法同样也是 someActionAsync 这 种格式，但是会增加一个 Executor  参数。CompletableFuture 里大约有五十种方法，但是可以进行归类，<br>变换类 thenApply： </p>
<p><img src="/../img/image35.jpeg" alt="image35"></p>
<p>关键入参是函数式接口 Function。它的入参是上一个阶段计算后的结果， 返回值是经过转化后结果。<br>消费类 thenAccept：</p>
<p><img src="/../img/image36.png" alt="image36"></p>
<p>关键入参是函数式接口 Consumer。它的入参是上一个阶段计算后的结果， 没有返回值。<br>执行操作类 thenRun：</p>
<p><img src="/../img/image37.jpeg" alt="image37"></p>
<p>对上一步的计算结果不关心，执行下一个操作，入参是一个 Runnable 的实 例，表示上一步完成后执行的操作。<br>结合转化类:</p>
<p><img src="/../img/image38.png" alt="image38"></p>
<p>需要上一步的处理返回值，并且 other 代表的 Comple有返回值之 后，利用这两个返回值，进行转换后返回指定类型的值。<br>两个 Comple是并行执行的， 它们之间并没有先后依赖顺序， other 并不会等待先前的 CompletableFuture 执行完毕后再执行。<br>结合转化类</p>
<p><img src="/../img/1711295266890.png" alt="1711295266890"></p>
<p>对于 Compose 可以连接两个 CompletableFuture，其内部处理逻辑是当第一 个 CompletableFuture 处理没有完成时会合并成一个 CompletableFuture,如果处理 完成，第二个 future 会紧接上一个 CompletableFuture 进行处理。<br>第一个 CompletableFuture 的处理结果是第二个 future 需要的输入参数。<br>结合消费类: </p>
<p><img src="/../img/1711295293561.png" alt="1711295293561"></p>
<p>需要上一步的处理返回值，并且 other 代表的 Comple有返回值之 后，利用这两个返回值， 进行消费<br>运行后执行类：<br><img src="/../img/1711295316641.png" alt="1711295316641"></p>
<p>不关心这两个 Comple的结果， 只关心这两个 Comple都执 行完毕，之后再进行操作（Runnable）。<br>取最快转换类：<br><img src="/../img/1711295353506.png" alt="1711295353506"></p>
<p>两个 Comple，谁计算的快， 我就用那个 Comple的结果进 行下一步的转化操 作。现实开发场景中，总会碰到有两种渠道完成同一个事情， 所以就可以调用这个方法，找一个最快 的结果进行处理。<br>取最快消费类：</p>
<p><img src="/../img/1711295374958.png" alt="1711295374958"></p>
<p>两个 Comple，谁计算的快， 我就用那个 Comple的结果进 行下一步的消费操 作。<br>取最快运行后执行类：<br><img src="/../img/1711295394714.png" alt="1711295394714"></p>
<p>两个 Comple，任何一个完成了都会执行下一步的操作（Runnable）。<br>异常补偿类：<br><img src="/../img/1711295411038.png" alt="1711295411038"></p>
<p>当运行时出现了异常，可以通过 excep进行补偿。<br>运行后记录结果类：<br><img src="/../img/1711295471465.png" alt="1711295471465"></p>
<p>action执行完毕后它的结果返回原始的 CompletableFuture 的计算结果或者返回 异常。所以不会对结果 产生任何的作用。<br>运行后处理结果类：<br><img src="/../img/1711295494071.png" alt="1711295494071"></p>
<p>运行完成时，对结果的处理。这里的完成时有两种情况，一种是正常执行， 返回值。另外一种是 遇到异常抛出造成程序的中断。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Radish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/03/14/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%80)-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/">http://example.com/2024/03/14/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%80)-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">萝卜的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></div><div class="post_share"><div class="social-share" data-image="/img/touxiang.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/14/Spring%E6%BA%90%E7%A0%81(%E5%8D%81%E4%BA%8C)-SpringMVC%E5%90%AF%E5%8A%A8%E4%B8%8E%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90(%E6%9C%AA%E5%AE%8C)/" title="Spring源码(十二)-SpringMVC启动与请求处理流程解析"><img class="cover" src="/../img/spring-%E5%B0%81%E9%9D%A2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring源码(十二)-SpringMVC启动与请求处理流程解析</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/12/Spring%E6%BA%90%E7%A0%81(%E5%8D%81%E4%B8%80)-Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Spring源码(十一)-Spring之事务底层源码解析"><img class="cover" src="/../img/spring-%E5%B0%81%E9%9D%A2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring源码(十一)-Spring之事务底层源码解析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%89)-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS&amp;Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/" title="并发编程(三)-并发编程之CAS&amp;Atomic原子操作详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-02</div><div class="title">并发编程(三)-并发编程之CAS&amp;Atomic原子操作详解</div></div></a></div><div><a href="/2024/03/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%BA%8C)-%E5%AF%BC%E8%87%B4JVM%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84ThreadLocal%E8%AF%A6%E8%A7%A3/" title="并发编程(二)-导致JVM内存泄露的ThreadLocal详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-27</div><div class="title">并发编程(二)-导致JVM内存泄露的ThreadLocal详解</div></div></a></div><div><a href="/2024/04/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E5%85%AD)-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%E4%B9%8BReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-07</div><div class="title"></div></div></a></div><div><a href="/2024/04/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%83)-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock&amp;StampLock%E8%AF%A6%E8%A7%A3/" title="并发编程(七)-读写锁ReentrantReadWriteLock&amp;StampLock详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-08</div><div class="title">并发编程(七)-读写锁ReentrantReadWriteLock&amp;StampLock详解</div></div></a></div><div><a href="/2024/04/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B9%9D)-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue%E5%AE%9E%E6%88%98%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" title="并发编程(九)-阻塞队列BlockingQueue实战及其原理分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-09</div><div class="title">并发编程(九)-阻塞队列BlockingQueue实战及其原理分析</div></div></a></div><div><a href="/2024/04/05/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%BA%94)-JUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9C%A8%E5%A4%A7%E5%8E%82%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E8%AF%A6%E8%A7%A3/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title"></div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">Radish</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">愿内心深处的懦弱 不再将我吞噬</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">一、基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1、进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">1.1.1.</span> <span class="toc-text">大厂面试题：进程间的通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%88Context-switch%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">2、上下文切换（Context switch）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">二、Java中的线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Java%E7%A8%8B%E5%BA%8F%E5%A4%A9%E7%94%9F%E5%B0%B1%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84"><span class="toc-number">2.1.</span> <span class="toc-text">1、Java程序天生就是多线程的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E4%B8%AD%E6%AD%A2"><span class="toc-number">2.2.</span> <span class="toc-text">2、线程的启动与中止</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%96%B0%E5%90%AF%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.2.2.</span> <span class="toc-text">面试题：新启线程有几种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%AD%A2"><span class="toc-number">2.2.3.</span> <span class="toc-text">中止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3run-%E5%92%8Cstart"><span class="toc-number">2.2.4.</span> <span class="toc-text">深入理解run()和start()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81-x2F-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.5.</span> <span class="toc-text">线程的状态/生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.6.</span> <span class="toc-text">其他的线程相关方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.2.7.</span> <span class="toc-text">线程的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">2.2.8.</span> <span class="toc-text">线程的调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B"><span class="toc-number">2.2.9.</span> <span class="toc-text">线程和协程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.9.1.</span> <span class="toc-text">内核线程实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.9.2.</span> <span class="toc-text">用户线程实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.9.3.</span> <span class="toc-text">混合实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.9.4.</span> <span class="toc-text">Java 线程的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">2.2.9.5.</span> <span class="toc-text">协程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.2.10.</span> <span class="toc-text">守护线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E5%92%8C%E5%8D%8F%E8%B0%83%E3%80%81-%E5%8D%8F%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text">3、线程间的通信和协调、 协作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">2.3.1.</span> <span class="toc-text">管道输入输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join-%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">join 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%86%85%E7%BD%AE%E9%94%81"><span class="toc-number">2.3.3.</span> <span class="toc-text">synchronized 内置锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%94%81%E5%92%8C%E7%B1%BB%E9%94%81"><span class="toc-number">2.3.4.</span> <span class="toc-text">对象锁和类锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%9A%84%E5%8A%A0%E9%94%81%E5%92%8C%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-number">2.3.5.</span> <span class="toc-text">错误的加锁和原因分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%EF%BC%8C%E6%9C%80%E8%BD%BB%E9%87%8F%E7%9A%84%E9%80%9A%E4%BF%A1-x2F-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.6.</span> <span class="toc-text">volatile，最轻量的通信/同步机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%AD%89%E5%BE%85-x2F-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">4、等待/通知机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%92%8C%E9%80%9A%E7%9F%A5%E7%9A%84%E6%A0%87%E5%87%86%E8%8C%83%E5%BC%8F"><span class="toc-number">2.4.1.</span> <span class="toc-text">等待和通知的标准范式</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E5%85%AD)%E2%80%94%E2%80%94JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/" title="深入理解JVM(六)——JVM调优实战及常量池详解"><img src="/../img/jvm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解JVM(六)——JVM调优实战及常量池详解"></a><div class="content"><a class="title" href="/2024/05/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E5%85%AD)%E2%80%94%E2%80%94JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/" title="深入理解JVM(六)——JVM调优实战及常量池详解">深入理解JVM(六)——JVM调优实战及常量池详解</a><time datetime="2024-05-10T13:43:00.000Z" title="发表于 2024-05-10 21:43:00">2024-05-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E4%BA%94)%E2%80%94%E2%80%94JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/" title="深入理解JVM(五)——JVM调优工具详解及调优实战"><img src="/../img/jvm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解JVM(五)——JVM调优工具详解及调优实战"></a><div class="content"><a class="title" href="/2024/05/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E4%BA%94)%E2%80%94%E2%80%94JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/" title="深入理解JVM(五)——JVM调优工具详解及调优实战">深入理解JVM(五)——JVM调优工具详解及调优实战</a><time datetime="2024-05-08T14:21:00.000Z" title="发表于 2024-05-08 22:21:00">2024-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E5%9B%9B)%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%BA%95%E5%B1%82%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/" title="深入理解JVM(四)——垃圾收集器与底层算法详解"><img src="/../img/jvm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解JVM(四)——垃圾收集器与底层算法详解"></a><div class="content"><a class="title" href="/2024/05/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E5%9B%9B)%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%BA%95%E5%B1%82%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/" title="深入理解JVM(四)——垃圾收集器与底层算法详解">深入理解JVM(四)——垃圾收集器与底层算法详解</a><time datetime="2024-05-08T12:43:00.000Z" title="发表于 2024-05-08 20:43:00">2024-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E4%B8%89)%E2%80%94%E2%80%94JVM%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/" title="深入理解JVM(三)——JVM对象创建与内存分配机制深度剖析"><img src="/../img/jvm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解JVM(三)——JVM对象创建与内存分配机制深度剖析"></a><div class="content"><a class="title" href="/2024/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E4%B8%89)%E2%80%94%E2%80%94JVM%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/" title="深入理解JVM(三)——JVM对象创建与内存分配机制深度剖析">深入理解JVM(三)——JVM对象创建与内存分配机制深度剖析</a><time datetime="2024-05-07T13:15:00.000Z" title="发表于 2024-05-07 21:15:00">2024-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E4%BA%8C)%E2%80%94%E2%80%94JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/" title="深入理解JVM(二)——JVM内存模型深度剖析与优化"><img src="/../img/jvm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解JVM(二)——JVM内存模型深度剖析与优化"></a><div class="content"><a class="title" href="/2024/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E4%BA%8C)%E2%80%94%E2%80%94JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/" title="深入理解JVM(二)——JVM内存模型深度剖析与优化">深入理解JVM(二)——JVM内存模型深度剖析与优化</a><time datetime="2024-05-06T14:10:00.000Z" title="发表于 2024-05-06 22:10:00">2024-05-06</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2023 - 2024 By Radish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>