<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java开发面试题总结 | 萝卜的博客</title><meta name="author" content="Radish"><meta name="copyright" content="Radish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Java基础1、面向对象什么是面向对象面向过程注重的是解决问题的过程和顺序。 面相对象解决问题的参与者和其所需要做事情。 例如：洗衣服 面向过程：1.打开洗衣机 2.放衣服 3.放洗衣粉 4.清洗 5.烘干 面向对象：拆除洗衣机和人两个对象，人：打开洗衣机，放衣服，放洗衣粉洗衣机：清洗，烘干 从以上例子能看出，面向过程比较直接高效，而面向对象更易于复用、扩展和维护  面向对象的三种特征封装 指">
<meta property="og:type" content="article">
<meta property="og:title" content="Java开发面试题总结">
<meta property="og:url" content="http://example.com/2024/05/14/Java%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="萝卜的博客">
<meta property="og:description" content="一、Java基础1、面向对象什么是面向对象面向过程注重的是解决问题的过程和顺序。 面相对象解决问题的参与者和其所需要做事情。 例如：洗衣服 面向过程：1.打开洗衣机 2.放衣服 3.放洗衣粉 4.清洗 5.烘干 面向对象：拆除洗衣机和人两个对象，人：打开洗衣机，放衣服，放洗衣粉洗衣机：清洗，烘干 从以上例子能看出，面向过程比较直接高效，而面向对象更易于复用、扩展和维护  面向对象的三种特征封装 指">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/jvm.jpg">
<meta property="article:published_time" content="2024-05-14T13:06:00.000Z">
<meta property="article:modified_time" content="2024-05-26T16:02:28.936Z">
<meta property="article:author" content="Radish">
<meta property="article:tag" content="Tomcat">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/jvm.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/05/14/Java%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java开发面试题总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-27 00:02:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li><li><a class="site-page child" href="/%E8%A7%86%E9%A2%91"><i class="fa-fw /movies/"></i><span> 1</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="萝卜的博客"><span class="site-name">萝卜的博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li><li><a class="site-page child" href="/%E8%A7%86%E9%A2%91"><i class="fa-fw /movies/"></i><span> 1</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java开发面试题总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-14T13:06:00.000Z" title="发表于 2024-05-14 21:06:00">2024-05-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-26T16:02:28.936Z" title="更新于 2024-05-27 00:02:28">2024-05-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%90%8E%E7%AB%AF/">Java后端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java开发面试题总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="一、Java基础"><a href="#一、Java基础" class="headerlink" title="一、Java基础"></a>一、Java基础</h1><h2 id="1、面向对象"><a href="#1、面向对象" class="headerlink" title="1、面向对象"></a>1、面向对象</h2><h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><p>面向过程注重的是解决问题的过程和顺序。</p>
<p>面相对象解决问题的参与者和其所需要做事情。</p>
<p>例如：洗衣服</p>
<p>面向过程：1.打开洗衣机 2.放衣服 3.放洗衣粉 4.清洗 5.烘干</p>
<p>面向对象：拆除洗衣机和人两个对象，<br>人：打开洗衣机，放衣服，放洗衣粉<br>洗衣机：清洗，烘干</p>
<p>从以上例子能看出，面向过程比较直接高效，而面向对象更易于复用、扩展和维护 </p>
<h3 id="面向对象的三种特征"><a href="#面向对象的三种特征" class="headerlink" title="面向对象的三种特征"></a>面向对象的三种特征</h3><p><strong>封装</strong></p>
<p>指将对象的状态和行为包装起来，隐藏其内部实现的细节，提供公共接口供外部调用。</p>
<p><strong>继承</strong></p>
<p>基于一个已有的类创建新的类，继承原有类的属性和方法， 实现代码的重用和扩展 。</p>
<p><strong>多态</strong></p>
<p>指同一操作作用于不同的对象，可以产生不同的结果。多态的实现依赖于对象的继承关系和方法的重载和重写。 </p>
<h2 id="2、JDK、JRM、JVM"><a href="#2、JDK、JRM、JVM" class="headerlink" title="2、JDK、JRM、JVM"></a>2、JDK、JRM、JVM</h2><p>JDK是Java开发工具包，包含java编译器javac，以及java运行时环境。</p>
<p>JRM是Java运行时环境，包括java运行时所需要类库，以及JVM。</p>
<p>JVM是java虚拟机。</p>
<p><img src="/../img/1715697625665.png" alt="1715697625665"></p>
<h2 id="3、-x3D-x3D-和equals的区别"><a href="#3、-x3D-x3D-和equals的区别" class="headerlink" title="3、==和equals的区别"></a>3、==和equals的区别</h2><p>对于基本数据类型，==和equals都是比较值是否相等。</p>
<p>对于引用数据类型，==比较的是对象存储的堆内存地址，equals需要看对象是否重写equals方法，若有重写，则根据重写逻辑比较对象里的属性；若没有则调用Object类的equals方法用==去比较。</p>
<h2 id="4、hashCode和equals"><a href="#4、hashCode和equals" class="headerlink" title="4、hashCode和equals"></a>4、hashCode和equals</h2><p><strong>hashCode</strong></p>
<p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有 hashCode() 函数。<br>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用 到了散列码！（可以快速找到所需要的对象）</p>
<p><strong>为什么要有hashCode：</strong> </p>
<p>以“HashSet如何检查重复”为例子来说明为什么要有hashCode：<br>对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，看该位置是否有 值，如果没有、HashSet会假设对象没有重复出现。但是如果发现有值，这时会调用equals（）方法来 检查两个对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会 重新散列到其他位置。这样就大大减少了equals的次数，相应就大大提高了执行速度。</p>
<ul>
<li>如果两个对象相等，则hashcode一定也是相同的 </li>
<li>两个对象相等,对两个对象分别调用equals方法都返回true </li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的 </li>
<li>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖 </li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ul>
<h2 id="5、final"><a href="#5、final" class="headerlink" title="5、final"></a>5、final</h2><p>最终的</p>
<ul>
<li>修饰类：表示类不可被继承 </li>
<li>修饰方法：表示方法不可被子类覆盖，但是可以重载 </li>
<li>修饰变量：表示变量一旦被赋值就不可以更改它的值</li>
</ul>
<p>（1）修饰成员变量</p>
<ul>
<li>如果final修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。</li>
<li>如果final修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。</li>
</ul>
<p>（2）修饰局部变量</p>
<p>系统不会为局部变量进行初始化，局部变量必须由程序员显示初始化。因此使用final修饰局部变量时， 即可以在定义时指定默认值（后面的代码不能对变量再赋值），也可以不指定默认值，而在后面的代码中对final变量赋初值（仅一次）</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalVar</span> {</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//再声明的时候就需要赋值 或者静态代码块赋值</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> &nbsp; &nbsp;static{</span></span><br><span class="line"><span class="comment"> &nbsp;  a = 0;</span></span><br><span class="line"><span class="comment"> &nbsp; &nbsp;}</span></span><br><span class="line"><span class="comment"> &nbsp; &nbsp;*/</span></span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">final</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//再声明的时候就需要赋值 或者代码块中赋值 &nbsp; 或者构造器赋值</span></span><br><span class="line">	<span class="comment">/*{</span></span><br><span class="line"><span class="comment"> &nbsp; &nbsp; &nbsp; &nbsp;b = 0;</span></span><br><span class="line"><span class="comment"> &nbsp; &nbsp;}*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">final</span> <span class="type">int</span> localA; &nbsp; <span class="comment">//局部变量只声明没有初始化，不会报错,与final无关。</span></span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;localA = <span class="number">0</span>;<span class="comment">//在使用之前一定要赋值</span></span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="comment">//localA = 1; 但是不允许第二次赋值</span></span><br><span class="line"> &nbsp;  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>（3）修饰基本类型数据和引用类型数据</p>
<ul>
<li>如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改； </li>
<li>如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。<strong>但是引用的值是可变的。</strong></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalReferenceTest</span>{</span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">final</span> <span class="type">int</span>[] iArr={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;iArr[<span class="number">2</span>]=-<span class="number">3</span>;<span class="comment">//合法 </span></span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;iArr=<span class="literal">null</span>;<span class="comment">//非法，对iArr不能重新赋值</span></span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">final</span> <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">25</span>);</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;p.setAge(<span class="number">24</span>);<span class="comment">//合法</span></span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;p=<span class="literal">null</span>;<span class="comment">//非法 </span></span><br><span class="line"> &nbsp; } &nbsp; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>**为什么局部内部类和匿名内部类只能访问局部final变量？ **</p>
<p>编译之后会生成两个class文件，Test.class Test1.class</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> { &nbsp; &nbsp; </span><br><span class="line">    } &nbsp; </span><br><span class="line"> &nbsp; &nbsp;<span class="comment">//局部final变量a,b</span></span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> b)</span> {<span class="comment">//jdk8在这里做了优化, 不用写,语法糖，但实际上也是有的，也不能修改</span></span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="comment">//匿名内部类</span></span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">new</span> <span class="title class_">Thread</span>(){</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(a);</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(b);</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };</span><br><span class="line"> &nbsp; &nbsp; &nbsp; }.start();</span><br><span class="line"> &nbsp; }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutClass</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outPrint</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InClass</span> {</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">InPrint</span><span class="params">()</span> {</span><br><span class="line">                System.out.println(x);</span><br><span class="line">                System.out.println(age);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InClass</span>().InPrint();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先需要知道的一点是: 内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。</p>
<p>这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有没有人再引用它时，才会死亡)。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的”copy”。这样就好像延长了局部变量的生命周期 </p>
<p>将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？</p>
<p>就将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量和方法的局部变量的一致性。这实际上也是一种妥协。使得局部变量与内部类内建立的拷贝保持一致。</p>
<h2 id="6、String、StringBuffer、StringBuilder"><a href="#6、String、StringBuffer、StringBuilder" class="headerlink" title="6、String、StringBuffer、StringBuilder"></a>6、String、StringBuffer、StringBuilder</h2><p>String是final修饰的，不可变，每次操作都会产生新的String对象</p>
<p>StringBuffer和StringBuilder都是在原对象上操作</p>
<p>StringBuffer是线程安全的，StringBuilder线程不安全的</p>
<p>StringBuffer方法都是synchronized修饰的</p>
<p>性能：StringBuilder &gt; StringBuffer &gt; String</p>
<p>场景：经常需要改变字符串内容时使用后面两个</p>
<p>优先使用StringBuilder，多线程使用共享变量时使用StringBuffer</p>
<h2 id="7、重载和重写的区别"><a href="#7、重载和重写的区别" class="headerlink" title="7、重载和重写的区别"></a>7、重载和重写的区别</h2><ul>
<li>重载</li>
</ul>
<p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</p>
<ul>
<li>重写</li>
</ul>
<p>发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。 </p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,String b)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,String b)</span></span><br><span class="line"><span class="comment">//编译报错</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="8、接口和抽象类的区别"><a href="#8、接口和抽象类的区别" class="headerlink" title="8、接口和抽象类的区别"></a>8、接口和抽象类的区别</h2><ul>
<li>抽象类可以存在普通成员函数，而接口中只能存在public abstract方法。</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的。</li>
<li>抽象类只能继承一个，接口可以实现多个。</li>
</ul>
<p>接口的设计目的，是对类的行为进行约束（更准确的说是一种“有”约束，因为接口不能规定类不可以有什么行为），也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制。 </p>
<p>而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行为的实现方式一致时（A的非真子集，记为B），可以让这些类都派生于一个抽象类。在这个抽象类中实现了B，避免让所有的子类来实现B，这就达到了代码复用的目的。而A减B的部分，留给各个子类自己实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来（否则当调用到A-B时，无法执行）。</p>
<p>抽象类是对类本质的抽象，表达的是<code>is a</code>的关系，比如： BMW is a Car 。抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。</p>
<p>而接口是对行为的抽象，表达的是 like a 的关系。比如： Bird like a Aircraft （像飞行器一样可以飞），但其本质上 is a <code>Bird </code>。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。</p>
<p>使用场景：当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。 </p>
<p>抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计 阶段会降低难度</p>
<h2 id="9、List和Set的区别"><a href="#9、List和Set的区别" class="headerlink" title="9、List和Set的区别"></a>9、List和Set的区别</h2><ul>
<li><p>List：有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用Iterator取出 所有元素，在逐一遍历，还可以使用get(int index)获取指定下标的元素 </p>
</li>
<li><p>Set：无序，不可重复，最多允许有一个Null元素对象，取元素时只能用iterator接口取得所有元素，在逐一遍历各个元素</p>
</li>
</ul>
<h2 id="10、ArrayList和LinkedList区别"><a href="#10、ArrayList和LinkedList区别" class="headerlink" title="10、ArrayList和LinkedList区别"></a>10、ArrayList和LinkedList区别</h2><p>ArrayList：基于动态数组，连续内存存储，适合下标访问（随机访问），扩容机制：因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动（往后复制一份，插入新元素），使用尾插法并指定初始容量可以极大提升性能、甚至超过linkedList（需要创建大量的node对象）</p>
<p>LinkedList：基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询：需要逐一遍历</p>
<p>遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过get(i)取得某一元素时都需 要对list重新进行遍历，性能消耗极大。</p>
<p>另外不要试图使用indexOf等返回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结果为空时会遍历整个列表。</p>
<h2 id="11、HashMap和HashTable有什么区别？其底层实现是什么？"><a href="#11、HashMap和HashTable有什么区别？其底层实现是什么？" class="headerlink" title="11、HashMap和HashTable有什么区别？其底层实现是什么？"></a>11、HashMap和HashTable有什么区别？其底层实现是什么？</h2><ol>
<li>区别：</li>
</ol>
<p>（1）HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；</p>
<p>（2）HashMap允许key和value为null，而HashTable不允许</p>
<ol start="2">
<li>底层实现：数组+链表实现</li>
</ol>
<p>jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在 </p>
<ul>
<li><p>计算key的hash值，二次hash然后对数组长度取模，对应到数组下标 </p>
</li>
<li><p>如果没有产生hash冲突（下标位置没有元素），则直接创建Node存入数组</p>
</li>
<li><p>如果产生hash冲突，先进行equal比较，相同则取代该元素，不同，则判断链表高度插入链表，链表高度达到8，并且数组长度到64则转变为红黑树，长度低于6则将红黑树转回链表</p>
</li>
<li><p>key为null，存在下标0的位置</p>
</li>
</ul>
<ol start="3">
<li>扩容</li>
</ol>
<p>当HashMap里面的元素个数超过临界值的时候会自动触发扩容。 临界值 = 负载因子 X 容量大小，负载因子的默认值是0.75，而容量大小是16。也就是说， 第1次扩容的动作会在元素个数达到12的时候触发，扩容的大小是原来的2倍。HashMap 的最大容量是Integer.MAX_VALUE也就是2的31次方减1。</p>
<p>由于动态扩容机制的存在，所以我们在实际应用的时候，最好在集合初始化的时候明确去指定集合的大小，从而避免频繁扩容带来性能上的消耗。</p>
<p>假设，我们向HashMap中插入1024个元素，如果按照默认容量大小是16的情况下，随着元素的不断增加，会造成至少7次扩容。而这7次扩容过程中，需要重新去创建新的Hash表，并且进行数据的迁移，对性能的影响是非常大的。</p>
<ol start="4">
<li>负载因子为什么默认0.75</li>
</ol>
<ul>
<li>负载因子的值越大，也就意味着触发扩容的元素个数就越多。虽然，它的整体空间利用率会比较高，但是Hash冲突的概率也会增加。 </li>
<li>那么，反之，负载因子的值越小，那么触发扩容元素的个数也就越少，也就意味着Hash冲突的概率也会减少。但是，对于内存空间的浪费自然就比较多了，而且还会增加扩容的频率。</li>
</ul>
<h2 id="12、ConcurrentHashMap原理，jdk7和jdk8版本的区别"><a href="#12、ConcurrentHashMap原理，jdk7和jdk8版本的区别" class="headerlink" title="12、ConcurrentHashMap原理，jdk7和jdk8版本的区别"></a>12、ConcurrentHashMap原理，jdk7和jdk8版本的区别</h2><h3 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h3><p>数据结构：ReentrantLock+Segment+HashEntry，一个Segment中包含一个HashEntry数组，每个 HashEntry又是一个链表结构</p>
<p>元素查询：二次hash，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部</p>
<p>锁：Segment分段锁 Segment继承了ReentrantLock，锁定操作的Segment，其他的Segment不受影 响，并发度为segment个数，可以通过构造函数指定，数组扩容不会影响其他的segment</p>
<p>get方法无需加锁，volatile保证可见性</p>
<h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><p>数据结构：synchronized+CAS+Node+红黑树，Node的val和next都用volatile修饰，保证可见性查找，替换，赋值操作都使用CAS。</p>
<p>锁：锁链表的head节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写操作、并发扩容</p>
<p>读操作无锁：<br>Node的val和next使用volatile修饰，读写线程对该变量互相可见<br>数组用volatile修饰，保证扩容时被读线程感知</p>
<h2 id="13、什么是字节码？采用字节码的好处是什么？"><a href="#13、什么是字节码？采用字节码的好处是什么？" class="headerlink" title="13、什么是字节码？采用字节码的好处是什么？"></a>13、什么是字节码？采用字节码的好处是什么？</h2><p>字节码是由Java编译器编译而来的代码，然后由JVM的解释器来将字节码转换为特定系统的机器码执行。因此字节码不面向任何特定的处理器，只面向虚拟机。</p>
<p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。 Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执 行的二进制机器码—-&gt;程序运行。</p>
<p><strong>采用字节码的好处</strong></p>
<ul>
<li><p>安全性，JVM执行检查</p>
</li>
<li><p>可移植性，只用面向JVM编程，由JVM将字节码转换成对应系统的机器码</p>
</li>
<li><p>性能，由于字节码是⼀种紧凑的⼆进制格式，相⽐于直接编译为机器码，可以更快地加载和传输，同时也可以</p>
<p>在运⾏时进⾏动态优化，提⾼程序的执⾏效率</p>
</li>
<li><p>可读性， 相⽐于直接编译为机器码，字节码具有更好的可读性，可以⽅便地进⾏反汇编和调试。</p>
</li>
</ul>
<h2 id="14、Java中的异常体系"><a href="#14、Java中的异常体系" class="headerlink" title="14、Java中的异常体系"></a>14、Java中的异常体系</h2><p>Java中的所有异常都来自顶级父类Throwable。</p>
<p>Throwable下有两个子类Exception和Error。 Error是程序无法处理的错误，一旦出现这个错误，则程序将被迫停止运行。 </p>
<p>Exception不会导致程序停止，又分为两个部分RunTimeException运行时异常和CheckedException检查异常。 RunTimeException常常发生在程序运行过程中，会导致程序当前线程执行失败。<br>CheckedException常 常发生在程序编译过程中，会导致程序编译不通过。</p>
<h2 id="15、Java类加载器"><a href="#15、Java类加载器" class="headerlink" title="15、Java类加载器"></a>15、Java类加载器</h2><p>JDK自带有三个类加载器：Bootstrap ClassLoader、ExtClassLoader、AppClassLoader。 BootStrapClassLoader是ExtClassLoader的父类加载器，默认负责加载%JAVA_HOME%lib下的jar包和class文件。<br>ExtClassLoader是AppClassLoader的父类加载器，负责加载%JAVA_HOME%/lib/ext文件夹下的jar包和class类。 AppClassLoader是自定义类加载器的父类，负责加载classpath下的类文件。<br>系统类加载器，线程上下文加载器<br>继承ClassLoader实现自定义类加载器。</p>
<h2 id="16、双亲委托模型"><a href="#16、双亲委托模型" class="headerlink" title="16、双亲委托模型"></a>16、双亲委托模型</h2><p><img src="/../img/1716044267013.png" alt="1716044267013"></p>
<p>双亲委派模型的好处：</p>
<ul>
<li>安全性，避免用户用自己编写的类动态替换Java的一些核心类。</li>
<li>同时也避免了类的重复加载，因为JVM中区分不同类，不仅仅是根据类名，相同的class文件被不同的ClassLoader加载就是不同的两个类。</li>
</ul>
<h2 id="17、GC如何判断对象可以被回收"><a href="#17、GC如何判断对象可以被回收" class="headerlink" title="17、GC如何判断对象可以被回收"></a>17、GC如何判断对象可以被回收</h2><ul>
<li>引用计数法：每个对象有一个引用计数属性， 新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。</li>
<li>可达性分析法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GCRoots 没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。</li>
</ul>
<blockquote>
<p>引用计数法，可能会出现A 引用了 B，B 又引用了 A，这时候就算他们都不再使用了，但因为相互引用计数器=1 永远无法被回收。</p>
</blockquote>
<p>GC Roots的对象有：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表）中引用的对象 </li>
<li>方法区中类静态属性引用的对象 </li>
<li>方法区中常量引用的对象 </li>
<li>本地方法栈中JNI(即一般说的Native方法)引用的对象</li>
</ul>
<p>可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会。对象被系统宣告死亡至少要经历两次标记过程：第一次是经过可达性分析发现没有与GC Roots相连接的引用链，第二次是在由虚拟机自动建立的Finalizer队列中判断是否需要执行finalize()方法。</p>
<p>当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活” </p>
<p>每个对象只能触发一次finalize()方法 </p>
<p>由于finalize()方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，不推荐大家使用，建议遗忘它。</p>
<h1 id="二、线程、并发相关"><a href="#二、线程、并发相关" class="headerlink" title="二、线程、并发相关"></a>二、线程、并发相关</h1><h2 id="1、线程的生命周期？线程有几种状态"><a href="#1、线程的生命周期？线程有几种状态" class="headerlink" title="1、线程的生命周期？线程有几种状态"></a>1、线程的生命周期？线程有几种状态</h2><ol>
<li>线程通常有五种状态，创建，就绪，运行、阻塞和死亡状态。</li>
<li>阻塞的情况又分为三种：<ol>
<li>等待阻塞：运行的线程执行wait方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待 池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify或notifyAll方法才能被唤醒，wait是object类的方法</li>
<li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。</li>
<li>其他阻塞：运行的线程执行sleep或join方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep状态超时、join等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 sleep是Thread类的方法。</li>
</ol>
</li>
</ol>
<p>1.新建状态（New）：新创建了一个线程对象。 </p>
<p>2.就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。 </p>
<p>3.运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。 </p>
<p>4.阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。 </p>
<p>5.死亡状态（Dead）：线程执行完了或者因异常退出了run方法，该线程结束生命周期。</p>
<h2 id="2、sleep-、wait-、join-、yield-的区别"><a href="#2、sleep-、wait-、join-、yield-的区别" class="headerlink" title="2、sleep()、wait()、join()、yield()的区别"></a>2、sleep()、wait()、join()、yield()的区别</h2><ol>
<li>锁池</li>
</ol>
<p>所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到后会进入就绪队列进行等待cpu资源分配。 </p>
<ol start="2">
<li>等待池</li>
</ol>
<p>当我们调用wait（）方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了 notify（）或notifyAll()后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出一个线程放到锁池，而notifyAll()是将等待池的所有线程放到锁池当中</p>
<p>1、sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。</p>
<p>2、sleep方法不会释放lock，但是wait会释放，而且会加入到等待队列中。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep就是把cpu的执行资格和执行权释放出去，不再运此线程，当定时时间结束再取回cpu资源，参与cpu的调度，获取到cpu资源后就可以继续运行了。而如果sleep时该线程有锁，那么sleep不会释放这个锁，而是把锁带着进入了冻结状态，也就是说其他需要这个锁的线程根本不可能获取到这个锁。也就是说无法执行程序。如果在睡眠期间其他线程调用了这个线程的interrupt方法，那么这个线程也会抛出interruptexception异常返回，这点和wait是一样的。</span><br></pre></td></tr></tbody></table></figure>

<p>3、sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字。</p>
<p>4、sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别人中断）。</p>
<p>5、sleep一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。</p>
<p>6、sleep会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。 </p>
<p>yield（）执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留了cpu的执行资格， 所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行</p>
<p>join（）执行后线程进入阻塞状态，例如在线程B中调用线程A的join（），那线程B会进入到阻塞队列，直到线程A结束或中断线程</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"22222222"</span>);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    t1.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    <span class="comment">// 这行代码必须要等t1全部执行完毕，才会执行</span></span><br><span class="line">    System.out.println(<span class="string">"1111"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="3、对线程安全的理解"><a href="#3、对线程安全的理解" class="headerlink" title="3、对线程安全的理解"></a>3、对线程安全的理解</h2><p>不是线程安全、应该是内存安全，堆是共享内存，可以被所有线程访问 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的</span><br></pre></td></tr></tbody></table></figure>

<p><strong>堆</strong>是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是用完了要还给操作系统，要不然就是内存泄漏。 </p>
<blockquote>
<p>在Java中，堆是Java虚拟机所管理的内存中最大的一块，是所有线程共享的一块内存区域，在虚拟机启动时创建。堆所存在的内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</p>
</blockquote>
<p><strong>栈</strong>是每个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是线程安全的。操作系统在切换线程的时候会自动切换栈。栈空间不需要在高级语言里面显式的分配和释放。</p>
<p>目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。 </p>
<p>在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。 </p>
<h2 id="4、Thread、Runable的区别"><a href="#4、Thread、Runable的区别" class="headerlink" title="4、Thread、Runable的区别"></a>4、Thread、Runable的区别</h2><p>Thread和Runnable的实质是继承关系，没有可比性。无论使用Runnable还是Thread，都会new  Thread，然后执行run方法。用法上，如果有复杂的线程操作需求，那就选择继承Thread，如果只是简单的执行一个任务，那就实现runnable。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会卖出多一倍的票</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>{</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">                System.out.println(<span class="string">"Thread ticket = "</span> + ticket--);</span><br><span class="line">                <span class="keyword">if</span>(ticket &lt; <span class="number">0</span>){</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常卖出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        MyThread2 mt=<span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(mt).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(mt).start();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>{</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">                System.out.println(<span class="string">"Runnable ticket = "</span> + ticket--);</span><br><span class="line">                <span class="keyword">if</span>(ticket &lt; <span class="number">0</span>){</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>原因是：MyThread创建了两个实例，自然会卖出两倍，属于用法错误</p>
<h2 id="5、对守护线程的理解"><a href="#5、对守护线程的理解" class="headerlink" title="5、对守护线程的理解"></a>5、对守护线程的理解</h2><p>守护线程：为所有非守护线程提供服务的线程；任何一个守护线程都是整个JVM中所有非守护线程的保姆；</p>
<p>守护线程类似于整个进程的一个默默无闻的小喽喽；它的生死无关重要，它却依赖整个进程而运行；哪天其他线程结束了，没有要执行的了，程序就结束了，理都没理守护线程，就把它中断了； </p>
<p>注意： 由于守护线程的终止是自身无法控制的，因此千万不要把IO、File等重要操作逻辑分配给它；因为它不靠谱；</p>
<p><strong>守护线程的作用是什么？</strong></p>
<p>举例， GC垃圾回收线程：就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。 </p>
<p>应用场景：<br>（1）来为其它线程提供服务支持的情况；<br>（2） 或者在任何情况下，程序结束时，这个线程必须正常且立刻关闭，就可以作为守护线程来使用；反之，如果一个正在执行某个操作的线程必须要正确地关闭掉否则就会出现不好的后果的话，那么这个线程就不能是守护线程，而是用户线程。通常都是些关键的事务，比方说，数据库录入或者更新，这些操作都是不能中断的。</p>
<p>thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个 IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。 </p>
<p>在Daemon线程中产生的新线程也是Daemon的。</p>
<p>守护线程不能用于去访问固有资源，比如读写操作或者计算逻辑。因为它会在任何时候甚至在一个操作的中间发生中断。</p>
<p>Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线程就不能用Java的线程池。</p>
<h2 id="6、ThreadLocal的原理和使用场景"><a href="#6、ThreadLocal的原理和使用场景" class="headerlink" title="6、ThreadLocal的原理和使用场景"></a>6、ThreadLocal的原理和使用场景</h2><p>每一个 Thread 对象均含有一个 ThreadLocalMap 类型的成员变量 threadLocals ，它存储本线程中所有ThreadLocal对象及其对应的值</p>
<p>ThreadLocalMap 由一个个 Entry 对象构成 </p>
<p>Entry 继承自&lt;WeakReference&gt; ，一个 Entry 由 ThreadLocal 对象和 Object 构成。由此可见， Entry 的key是ThreadLocal对象，并且是一个弱引用。当没指向key的强引用后，该 key就会被垃圾收集器回收</p>
<p>当执行set方法时，ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key，将值存储进ThreadLocalMap对象中。 </p>
<p>get方法执行过程类似。ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap 对象。再以当前ThreadLocal对象为key，获取对应的value。</p>
<p>由于每一条线程均含有各自私有的ThreadLocalMap容器，这些容器相互独立互不影响，因此不会存在线程安全性问题，从而也无需使用同步机制来保证多条线程访问容器的互斥性。 </p>
<p><strong>使用场景：</strong></p>
<p>1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。 </p>
<p>2、线程间数据隔离 </p>
<p>3、进行事务操作，用于存储线程事务信息。</p>
<p>4、数据库连接，Session会话管理。</p>
<p><img src="/../img/1716046487216.png" alt="1716046487216"></p>
<h2 id="7、ThreadLocal内存泄露原因，如何避免"><a href="#7、ThreadLocal内存泄露原因，如何避免" class="headerlink" title="7、ThreadLocal内存泄露原因，如何避免"></a>7、ThreadLocal内存泄露原因，如何避免</h2><p>内存泄露为程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光，不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。</p>
<p><strong>强引用</strong>：使用最普遍的引用(new)，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足， Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</p>
<p>如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时间就会回收该对象。</p>
<p><strong>弱引用</strong>：JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用 java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。</p>
<p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用弱引用的ThreadLocal 实例，value为线程变量的副本</p>
<p><img src="/../img/1716046617106.png" alt="1716046617106"></p>
<p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部强引用时，Key(ThreadLocal)势必会被GC回收，这样就会导致ThreadLocalMap中key为null， 而value还存在着强引用，只有thread线程退出以后,value的强引用链条才会断掉，但如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链（红色链条）</p>
<p>key 使用强引用</p>
<p>当ThreadLocalMap的key为强引用回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</p>
<p>key 使用弱引用</p>
<p>当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，在下一次ThreadLocalMap调用set()，get()，remove()方法的时候会被清除value值。</p>
<p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p>
<p>ThreadLocal正确的使用方法：</p>
<ul>
<li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li>
<li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。</li>
</ul>
<h2 id="8、并发、并行、串行的区别"><a href="#8、并发、并行、串行的区别" class="headerlink" title="8、并发、并行、串行的区别"></a>8、并发、并行、串行的区别</h2><p>串行在时间上不可能发生重叠，前一个任务没搞定，下一个任务就只能等着。 </p>
<p>并行在时间上是重叠的，两个任务在同一时刻互不干扰的同时执行。 </p>
<p>并发允许两个任务彼此干扰。统一时间点、只有一个任务运行，交替执行。</p>
<h2 id="9、并发的三大特性"><a href="#9、并发的三大特性" class="headerlink" title="9、并发的三大特性"></a>9、并发的三大特性</h2><ul>
<li>原子性</li>
</ul>
<p>原子性是指在一个操作中cpu不可以在中途暂停然后再调度，即不被中断操作，要不全部执行完成，要不都不执行。就好比转账，从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元， 往账户B加上1000元。2个操作必须全部完成。 </p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">()</span> {</span><br><span class="line"> &nbsp; &nbsp;count++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>1：将 count 从主存读到工作内存中的副本中 </p>
<p>2：+1的运算 </p>
<p>3：将结果写入工作内存 </p>
<p>4：将工作内存的值刷回主存(什么时候刷入由操作系统决定，不确定的)</p>
<p>那程序中原子性指的是最小的操作单元，比如自增操作，它本身其实并不是原子性操作，分了3步的，包括读取变量的原始值、进行加1操作、写入工作内存。所以在多线程中，有可能一个线程还没自增完，可能才执行到第二部，另一个线程就已经读取了值，导致结果错误。那如果我们能保证自增操作是一个原子性的操作，那么就能保证其他线程读取到的一定是自增后的数据。</p>
<p><strong>关键字</strong>：synchronized </p>
<ul>
<li>可见性</li>
</ul>
<p>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 </p>
<p>若两个线程在不同的cpu，那么线程1改变了i的值还没刷新到主存，线程2又使用了i，那么这个i值肯定还是之前的，线程1对变量的修改线程没看到这就是可见性问题。 </p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> {</span><br><span class="line">    a = <span class="number">2</span>; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="comment">//1</span></span><br><span class="line">    flag = <span class="literal">true</span>; &nbsp; &nbsp; &nbsp; &nbsp;<span class="comment">//2</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multiply</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (flag) { &nbsp; &nbsp; &nbsp; &nbsp; <span class="comment">//3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> a * a;<span class="comment">//4</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果， 再到线程1，这时候a才赋值为2,很明显迟了一步 </p>
<p><strong>关键字</strong>：volatile、synchronized volatile</p>
<p>本身就包含了禁止指令重排序的语义，而synchronized关键字是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则明确的。</p>
<p>synchronized关键字同时满足以上三种特性，但是volatile关键字不满足原子性。</p>
<p>在某些情况下，volatile的同步机制的性能确实要优于锁(使用synchronized关键字或 java.util.concurrent包里面的锁)，因为volatile的总开销要比锁低。 </p>
<p>我们判断使用volatile还是加锁的唯一依据就是volatile的语义能否满足使用的场景(原子性) </p>
<h2 id="10、volatile"><a href="#10、volatile" class="headerlink" title="10、volatile"></a>10、volatile</h2><ol>
<li>保证被volatile修饰的共享变量对所有线程总是可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop){</span><br><span class="line"> &nbsp; &nbsp;doSomething();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="literal">true</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>如果线程2改变了stop的值，线程1一定会停止吗？不一定。当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。 </p>
<ol start="2">
<li>禁止指令重排序优化。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> {</span><br><span class="line">    a = <span class="number">2</span>; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="comment">//1</span></span><br><span class="line">    flag = <span class="literal">true</span>; &nbsp; &nbsp; &nbsp; &nbsp;<span class="comment">//2</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multiply</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (flag) { &nbsp; &nbsp; &nbsp; &nbsp; <span class="comment">//3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> a * a;<span class="comment">//4</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果， 再到线程1，这时候a才赋值为2,很明显迟了一步。 </p>
<p>但是用volatile修饰之后就变得不一样了</p>
<p>第一：使用volatile关键字会强制将修改的值立即写入主存； </p>
<p>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）； </p>
<p>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p><code>inc++</code>; 其实是两个步骤，先加加，然后再赋值。不是原子性操作，所以volatile不能保证线程安全。 </p>
<h2 id="11、为什么使用线程池？解释下线程池的参数？"><a href="#11、为什么使用线程池？解释下线程池的参数？" class="headerlink" title="11、为什么使用线程池？解释下线程池的参数？"></a>11、为什么使用线程池？解释下线程池的参数？</h2><p>1、降低资源消耗；提高线程利用率，降低创建和销毁线程的消耗。 </p>
<p>2、提高响应速度；任务来了，直接有线程可用可执行，而不是先创建线程，再执行。 </p>
<p>3、提高线程的可管理性；线程是稀缺资源，使用线程池可以统一分配调优监控。</p>
<ul>
<li><code>corePoolSize</code>代表核心线程数，也就是正常情况下创建工作的线程数，这些线程创建后并不会消除，而是一种常驻线程</li>
<li><code>maxinumPoolSize</code>代表的是最大线程数，它与核心线程数相对应，表示最大允许被创建的线程数，比如当前任务较多，将核心线程数都用完了，还无法满足需求时，此时就会创建新的线程，但是线程池内线程总数不会超过最大线程数</li>
<li><code>keepAliveTime</code>、<code>unit</code>表示超出核心线程数之外的线程的空闲存活时间，也就是核心线程不会消除，但是超出核心线程数的部分线程如果空闲一定的时间则会被消除,我们可以通过<code>setKeepAliveTime</code>来设置空闲时间</li>
<li><code>workQueue</code>用来存放待执行的任务，假设我们现在核心线程都已被使用，还有任务进来则全部放入队列，直到整个队列被放满但任务还再持续进入则会开始创建新的线程</li>
<li><code>ThreadFactory</code>实际上是一个线程工厂，用来生产线程执行任务。我们可以选择使用默认的创建工厂，产生的线程都在同一个组内，拥有相同的优先级，且都不是守护线程。当然我们也可以选择自定义线程工厂，一般我们会根据业务来制定不同的线程工厂</li>
<li><code>Handler</code>任务拒绝策略，有两种情况，第一种是当我们调用 shutdown 等方法关闭线程池后，这时候即使线程池内部还有没执行完的任务正在执行，但是由于线程池已经关闭，我们再继续想线程池提交任务就会遭到拒绝。另一种情况就是当达到最大线程数，线程池已经没有能力继续处理新提交的任务时，这是也就拒绝</li>
</ul>
<h2 id="12、简述线程池处理流程"><a href="#12、简述线程池处理流程" class="headerlink" title="12、简述线程池处理流程"></a>12、简述线程池处理流程</h2><p><img src="/../img/1716049671621.png" alt="1716049671621"></p>
<h2 id="13、线程池中阻塞队列的作用？为什么是先添加列队而不是先创建最大线程？"><a href="#13、线程池中阻塞队列的作用？为什么是先添加列队而不是先创建最大线程？" class="headerlink" title="13、线程池中阻塞队列的作用？为什么是先添加列队而不是先创建最大线程？"></a>13、线程池中阻塞队列的作用？为什么是先添加列队而不是先创建最大线程？</h2><p>1、一般的队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留当前的任务了，阻塞队列通过阻塞可以保留住当前想要继续入队的任务。</p>
<p>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。</p>
<p>阻塞队列自带阻塞和唤醒的功能，不需要额外处理，无任务执行时,线程池利用阻塞队列的take方法挂起，从而维持核心线程的存活、不至于一直占用cpu资源 </p>
<p>2、在创建新线程的时候，是要获取全局锁的，这个时候其它的就得阻塞，影响了整体效率。</p>
<p>就好比一个企业里面有10个（core）正式工的名额，最多招10个正式工，要是任务超过正式工人数 （task &gt; core）的情况下，工厂领导（线程池）不是首先扩招工人，还是这10人，但是任务可以稍微积压一下，即先放到队列去（代价低）。10个正式工慢慢干，迟早会干完的，要是任务还在继续增加，超过正式工的加班忍耐极限了（队列满了），就的招外包帮忙了（注意是临时工）要是正式工加上外包还是不能完成任务，那新来的任务就会被领导拒绝了（线程池的拒绝策略）。</p>
<h2 id="14、线程池中线程复用原理"><a href="#14、线程池中线程复用原理" class="headerlink" title="14、线程池中线程复用原理"></a>14、线程池中线程复用原理</h2><p>线程池将线程和任务进行解耦，线程是线程，任务是任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制。</p>
<p>在线程池中，同一个线程可以从阻塞队列中不断获取新任务来执行，其核心原理在于线程池对  Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中不停检查是否有任务需要被执行，如果有则直接执行，也就是调用任务中的 run 方法，将 run 方法当成一个普通的方法执行，通过这种方式只使用固定的线程就将所有任务的 run 方法串联起来。</p>
<h1 id="三、Spring"><a href="#三、Spring" class="headerlink" title="三、Spring"></a>三、Spring</h1><h2 id="1、如何实现一个IOC容器"><a href="#1、如何实现一个IOC容器" class="headerlink" title="1、如何实现一个IOC容器"></a>1、如何实现一个IOC容器</h2><ul>
<li>配置文件中指定需要扫描的包路径 </li>
<li>定义一些注解，分别表示访问控制层、业务服务层、数据持久层、依赖注入注解、获取配置文件注解 </li>
<li>从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路径下所有以.class结尾的文件添加到一个Set集合中进行存储</li>
<li>遍历这个set集合，获取在类上有指定注解的类，并将其交给IOC容器，定义一个安全的Map用来存储这些对象 </li>
<li>遍历这个IOC容器，获取到每一个类的实例，判断里面是否有依赖其他的类的实例，然后进行递归注入</li>
</ul>
<h2 id="2、Spring是什么？"><a href="#2、Spring是什么？" class="headerlink" title="2、Spring是什么？"></a>2、Spring是什么？</h2><p>轻量级的开源的J2EE框架。它是一个容器框架，用来装javabean（java对象），中间层框架（万能胶） 可以起一个连接作用，比如说把Struts和hibernate粘合在一起运用，可以让我们的企业开发更快、更简洁。</p>
<p>Spring是一个轻量级的控制反转（IoC)和面向切面（AOP）的容器框架  </p>
<ul>
<li>从大小与开销两方面而言Spring都是轻量级的。</li>
<li>通过控制反转(IoC)的技术达到松耦合的目的。</li>
<li>提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发。</li>
<li>包含并管理应用对象(Bean)的配置和生命周期，这个意义上是一个容器。</li>
<li>将简单的组件配置、组合成为复杂的应用，这个意义上是一个框架。</li>
</ul>
<h2 id="3、谈谈你对AOP的理解"><a href="#3、谈谈你对AOP的理解" class="headerlink" title="3、谈谈你对AOP的理解"></a>3、谈谈你对AOP的理解</h2><p>系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。</p>
<p>当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。</p>
<p>例如日志功能。 日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。</p>
<p>在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>AOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象 （具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外地做一些事情，在某个方法执行之后额外的做一些事情 </p>
<h2 id="4、谈谈你对IOC的理解"><a href="#4、谈谈你对IOC的理解" class="headerlink" title="4、谈谈你对IOC的理解"></a>4、谈谈你对IOC的理解</h2><p><strong>ioc容器：</strong>实际上就是个map（key，value），里面存的是各种对象（在xml里配置的bean节点、 @repository、@service、@controller、@component），在项目启动的时候会读取配置文件里面的bean节点，根据全限定类名使用反射创建对象放到map里、扫描到打上上述注解的类还是通过反射创建对象放到map里。</p>
<p>这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过DI注入 （autowired、resource等注解，xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref属性根据id注入，也会扫描这些注解，根据类型或id注入；id就是对象名）。 </p>
<p><strong>控制反转：</strong>没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须 主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</p>
<p>引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p>
<p>通过前后的对比，不难看出来：对象A获得依赖对象B的过程，由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。 </p>
<p>全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p>
<p><strong>依赖注入：</strong> “获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器 主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p>
<h2 id="5、BeanFactory和ApplicationContext有什么区别？"><a href="#5、BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="5、BeanFactory和ApplicationContext有什么区别？"></a>5、BeanFactory和ApplicationContext有什么区别？</h2><p>ApplicationContext是BeanFactory的子接口，ApplicationContext提供了更完整的功能：</p>
<p>①继承MessageSource，因此支持国际化。 </p>
<p>②统一的资源文件访问方式。 </p>
<p>③提供在监听器中注册bean的事件。 </p>
<p>④同时加载多个配置文件。 </p>
<p>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。 </p>
<ul>
<li>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</li>
<li>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</li>
<li>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置 Bean较多时，程序启动较慢。 </li>
<li>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</li>
<li>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</li>
</ul>
<h2 id="6、描述一下Spring-Bean的生命周期？"><a href="#6、描述一下Spring-Bean的生命周期？" class="headerlink" title="6、描述一下Spring Bean的生命周期？"></a>6、描述一下Spring Bean的生命周期？</h2><p>1、解析类得到BeanDefinition </p>
<p>2、如果有多个构造方法，则要推断构造方法 </p>
<p>3、确定好构造方法后，进行实例化得到一个对象 </p>
<p>4、对对象中的加了@Autowired注解的属性进行属性填充 </p>
<p>5、回调Aware方法，比如BeanNameAware，BeanFactoryAware </p>
<p>6、调用BeanPostProcessor的初始化前的方法 </p>
<p>7、调用初始化方法 </p>
<p>8、调用BeanPostProcessor的初始化后的方法，在这里会进行AOP </p>
<p>9、如果当前创建的bean是单例的则会把bean放入单例池 </p>
<p>10、使用bean </p>
<p>11、Spring容器关闭时调用DisposableBean中destory()方法 </p>
<h2 id="7、解释下Spring支持的几种bean的作用域？"><a href="#7、解释下Spring支持的几种bean的作用域？" class="headerlink" title="7、解释下Spring支持的几种bean的作用域？"></a>7、解释下Spring支持的几种bean的作用域？</h2><ul>
<li><p>singleton：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。该对象的生命周期是与Spring IOC容器一致的（但在第一次被注入时才会创建）。 </p>
</li>
<li><p>prototype：为每一个bean请求提供一个实例。在每次注入时都会创建一个新的对象 </p>
</li>
<li><p>request：bean被定义为在每个HTTP请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象。 </p>
</li>
<li><p>session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean 会随之失效。 </p>
</li>
<li><p>application：bean被定义为在ServletContext的生命周期中复用一个单例对象。 </p>
</li>
<li><p>websocket：bean被定义为在websocket的生命周期中复用一个单例对象。 </p>
</li>
<li><p>global-session：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。</p>
</li>
</ul>
<h2 id="8、Spring框架中的单例Bean是线程安全的么？"><a href="#8、Spring框架中的单例Bean是线程安全的么？" class="headerlink" title="8、Spring框架中的单例Bean是线程安全的么？"></a>8、Spring框架中的单例Bean是线程安全的么？</h2><p>Spring中的Bean默认是单例模式的，框架并没有对bean进行多线程的封装处理。</p>
<p>如果Bean是有状态的，那就需要开发人员自己来进行线程安全的保证，最简单的办法就是改变bean的作用域，把 “singleton”改为’‘protopyte’ 这样每次请求Bean就相当于是 new Bean() 这样就可以保证线程的安全了。</p>
<ul>
<li>有状态就是有数据存储功能</li>
<li>无状态就是不会保存数据 controller、service和dao层本身并不是线程安全的，只是如果只是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是自己的线程的工作内存，是安全的。</li>
</ul>
<p>Dao会操作数据库Connection，Connection是带有状态的，比如说数据库事务，Spring的事务管理器使用Threadlocal为不同线程维护了一套独立的connection副本，保证线程之间不会互相影响（Spring 是如何保证事务获取同一个Connection的） </p>
<p>不要在bean中声明任何有状态的实例变量或类变量，如果必须如此，那么就使用ThreadLocal把变量变为线程私有的，如果bean的实例变量或类变量需要在多个线程之间共享，那么就只能使用 synchronized、lock、CAS等这些实现线程同步的方法了。 </p>
<h2 id="9、Spring框架中都用到了哪些设计模式？"><a href="#9、Spring框架中都用到了哪些设计模式？" class="headerlink" title="9、Spring框架中都用到了哪些设计模式？"></a>9、Spring框架中都用到了哪些设计模式？</h2><p>简单工厂：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定</span><br></pre></td></tr></tbody></table></figure>

<p>工厂方法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</span><br></pre></td></tr></tbody></table></figure>

<p>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring对单例的实现： spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是任意的java对象。</span><br></pre></td></tr></tbody></table></figure>

<p>适配器模式： </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替controller执行相应的方法。这样在扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。</span><br></pre></td></tr></tbody></table></figure>

<p>装饰器模式：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</span><br></pre></td></tr></tbody></table></figure>

<p>动态代理： </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">切面在应用运行的时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象创建动态的创建一个代理对象。SpringAOP就是以这种方式织入切面的。</span><br><span class="line">织入：把切面应用到目标对象并创建新的代理对象的过程。</span><br></pre></td></tr></tbody></table></figure>

<p>观察者模式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring的事件驱动模型使用的是 观察者模式 ，Spring中Observer模式常用的地方是listener的实现。</span><br></pre></td></tr></tbody></table></figure>

<p>策略模式： </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了Resource接口来访问底层资源。</span><br></pre></td></tr></tbody></table></figure>

<p>模板方法：父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现。 </p>
<p>最大的好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父类中预先写好了。 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">refresh方法</span><br></pre></td></tr></tbody></table></figure>



<h2 id="10、Spring事务的实现方式和原理以及隔离级别？"><a href="#10、Spring事务的实现方式和原理以及隔离级别？" class="headerlink" title="10、Spring事务的实现方式和原理以及隔离级别？"></a>10、Spring事务的实现方式和原理以及隔离级别？</h2><p>在使用Spring框架时，可以有两种使用事务的方式，一种是编程式的，一种是申明式的，@Transactional注解就是申明式的。</p>
<p>首先，事务这个概念是数据库层面的，Spring只是基于数据库中的事务进行了扩展，以及提供了一些能让程序员更加方便操作事务的方式。</p>
<p>比如我们可以通过在某个方法上增加@Transactional注解，就可以开启事务，这个方法中所有的sql都会在一个事务中执行，统一成功或失败。</p>
<p>在一个方法上加了@Transactional注解后，Spring会基于这个类生成一个代理对象，会将这个代理对象作为bean，当在使用这个代理对象的方法时，如果这个方法上存在@Transactional注解，那么代理逻辑会先把事务的自动提交设置为false，然后再去执行原本的业务逻辑方法，如果执行业务逻辑方法没有出现异常，那么代理逻辑中就会将事务进行提交，如果执行业务逻辑方法出现了异常，那么则会将事务进行回滚。</p>
<p>当然，针对哪些异常回滚事务是可以配置的，可以利用@Transactional注解中的rollbackFor属性进行配置，默认情况下会对RuntimeException和Error进行回滚。</p>
<p>spring事务隔离级别就是数据库的隔离级别：外加一个默认级别</p>
<ul>
<li>read uncommitted（未提交读）</li>
<li>read committed（提交读、不可重复读）</li>
<li>repeatable read（可重复读）</li>
<li>serializable（可串行化）</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据库的配置隔离级别是Read Commited,而Spring配置的隔离级别是Repeatable Read，请问这时隔离级别是以哪一个为准？</span><br><span class="line">以Spring配置的为准，如果spring设置的隔离级别数据库不支持，效果取决于数据库</span><br></pre></td></tr></tbody></table></figure>



<h2 id="11、Spring事务传播机制"><a href="#11、Spring事务传播机制" class="headerlink" title="11、Spring事务传播机制"></a>11、Spring事务传播机制</h2><p>多个事务方法相互调用时,事务如何在这些方法间传播</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法A是一个事务的方法，方法A执行过程中调用了方法B，那么方法B有无事务以及方法B对事务的要求不同都会对方法A的事务具体执行造成影响，同时方法A的事务对方法B的事务执行也有影响，这种影响具体是什么就由两个方法所定义的事务传播类型所决定。</span><br></pre></td></tr></tbody></table></figure>

<p>REQUIRED(Spring默认的事务传播类型)：如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务</p>
<p>SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行 </p>
<p>MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。 </p>
<p>REQUIRES_NEW：创建一个新事务，如果存在当前事务，则挂起该事务。 </p>
<p>NOT_SUPPORTED：以非事务方式执行,如果当前存在事务，则挂起当前事务 </p>
<p>NEVER：不使用事务，如果当前事务存在，则抛出异常 </p>
<p>NESTED：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务） </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">和REQUIRES_NEW的区别 </span><br><span class="line">REQUIRES_NEW是新建一个事务并且新开启的这个事务与原有事务无关，而NESTED则是当前存在事务时（我们把当前事务称之为父事务）会开启一个嵌套事务（称之为一个子事务）。 </span><br><span class="line">在NESTED情况下父事务回滚时，子事务也会回滚，而在REQUIRES_NEW情况下，原有事务回滚，不会影响新开启的事务。 </span><br><span class="line"></span><br><span class="line">和REQUIRED的区别 </span><br><span class="line">REQUIRED情况下，调用方存在事务时，则被调用方和调用方使用同一事务，那么被调用方出现异常时，由于共用一个事务，所以无论调用方是否catch其异常，事务都会回滚 </span><br><span class="line">而在NESTED情况下，被调用方发生异常时，调用方可以catch其异常，这样只有子事务回滚，父事务不受影响</span><br></pre></td></tr></tbody></table></figure>



<h2 id="12、Spring事务什么时候会失效"><a href="#12、Spring事务什么时候会失效" class="headerlink" title="12、Spring事务什么时候会失效?"></a>12、Spring事务什么时候会失效?</h2><p>spring事务的原理是AOP，进行了切面增强，那么失效的根本原因是这个AOP不起作用了！常见情况有如下几种</p>
<p>1、发生自调用，类里面使用this调用本类的方法（this通常省略），此时这个this对象不是代理类，而是UserService对象本身！</p>
<p>2、方法不是public的</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Transactional 只能用于 public 的方法上，否则事务会失效，如果要用在非 public 方法上，可以开启 AspectJ 代理模式。</span><br></pre></td></tr></tbody></table></figure>

<p>3、数据库不支持事务 </p>
<p>4、没有被spring管理 </p>
<p>5、异常被吃掉，事务不会回滚(或者抛出的异常没有被定义，默认为RuntimeException) </p>
<h2 id="13、什么是bean的自动装配，有哪些方式？"><a href="#13、什么是bean的自动装配，有哪些方式？" class="headerlink" title="13、什么是bean的自动装配，有哪些方式？"></a>13、什么是bean的自动装配，有哪些方式？</h2><p>开启自动装配，只需要在xml配置文件中定义“autowire”属性。 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id="cutomer" class="com.xxx.xxx.Customer" autowire="" /&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>autowire属性有五种装配的方式：</p>
<ul>
<li>no – 缺省情况下，自动配置是通过“ref”属性手动设定 。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">手动装配：以value或ref的方式明确指定属性值都是手动装配。</span><br><span class="line">需要通过‘ref’属性来连接bean。</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>byName-根据bean的属性名称进行自动装配。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cutomer的属性名称是person，Spring会将bean id为person的bean通过setter方法进行自动装配。</span><br><span class="line">&lt;bean id="cutomer" class="com.xxx.xxx.Cutomer" autowire="byName"/&gt;</span><br><span class="line">&lt;bean id="person" class="com.xxx.xxx.Person"/&gt;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>byType-根据bean的类型进行自动装配。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cutomer的属性person的类型为Person，Spirng会将Person类型通过setter方法进行自动装配。</span><br><span class="line">&lt;bean id="cutomer" class="com.xxx.xxx.Cutomer" autowire="byType"/&gt;</span><br><span class="line">&lt;bean id="person" class="com.xxx.xxx.Person"/&gt;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>constructor-类似byType，不过是应用于构造器的参数。如果一个bean与构造器参数的类型形同，则进行自动装配，否则导致异常。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cutomer构造函数的参数person的类型为Person，Spirng会将Person类型通过构造方法进行自动装配。</span><br><span class="line">&lt;bean id="cutomer" class="com.xxx.xxx.Cutomer" autowire="construtor"/&gt;</span><br><span class="line">&lt;bean id="person" class="com.xxx.xxx.Person"/&gt;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>autodetect-如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。</span><br></pre></td></tr></tbody></table></figure>

<p>@Autowired自动装配bean，可以在字段、setter方法、构造函数上使用。</p>
<h1 id="四、springmvc、springBoot"><a href="#四、springmvc、springBoot" class="headerlink" title="四、springmvc、springBoot"></a>四、springmvc、springBoot</h1><h2 id="1、Spring-Boot、Spring-MVC-和-Spring-有什么区别"><a href="#1、Spring-Boot、Spring-MVC-和-Spring-有什么区别" class="headerlink" title="1、Spring Boot、Spring MVC 和 Spring 有什么区别"></a>1、Spring Boot、Spring MVC 和 Spring 有什么区别</h2><p>spring是一个IOC容器，用来管理Bean，使用依赖注入实现控制反转，可以很方便的整合各种框架，提供AOP机制弥补OOP的代码重复问题、更方便将不同类不同方法中的共同处理抽取成切面、自动注入给方法执行，比如日志、异常等 </p>
<p>springmvc是spring对web框架的一个解决方案，提供了一个总的前端控制器Servlet，用来接收请求，然后定义了一套路由策略（url到handle的映射）及适配执行handle，将handle结果使用视图解析技术生成视图展现给前端</p>
<p>springboot是spring提供的一个快速开发工具包，让程序员能更方便、更快速的开发spring+springmvc 应用，简化了配置（约定了默认配置），整合了一系列的解决方案（starter机制）、redis、 mongodb、es，可以开箱即用</p>
<h2 id="2、SpringMVC-工作流程"><a href="#2、SpringMVC-工作流程" class="headerlink" title="2、SpringMVC 工作流程"></a>2、SpringMVC 工作流程</h2><p>1）用户发送请求至前端控制器 DispatcherServlet。 </p>
<p>2）DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。 </p>
<p>3）处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器及处理器拦截器 (如果有则生成)一并返回给 DispatcherServlet。 </p>
<p>4）DispatcherServlet 调用 HandlerAdapter 处理器适配器。 </p>
<p>5）HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器) </p>
<p>6）Controller 执行完成返回 ModelAndView。 </p>
<p>7）HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。</p>
<p>8） DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。 </p>
<p>9）ViewReslover 解析后返回具体 View。 </p>
<p>10）DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。 </p>
<p>11）DispatcherServlet 响应用户。</p>
<p><img src="/../img/1716215084807.png" alt="1716215084807"></p>
<h2 id="3、Spring-MVC的主要组件？"><a href="#3、Spring-MVC的主要组件？" class="headerlink" title="3、Spring MVC的主要组件？"></a>3、Spring MVC的主要组件？</h2><p>Handler：也就是处理器。它直接应对着MVC中的C也就是Controller层，它的具体表现形式有很多，可以是类，也可以是方法。在Controller层中@RequestMapping标注的所有方法都可以看成是一个 Handler，只要可以实际处理请求就可以是Handler </p>
<p>1、HandlerMapping<br>initHandlerMappings(context)，处理器映射器，根据用户请求的资源uri来查找Handler的。在 SpringMVC中会有很多请求，每个请求都需要一个Handler处理，具体接收到一个请求之后使用哪个 Handler进行，这就是HandlerMapping需要做的事。</p>
<p>2、HandlerAdapter<br>initHandlerAdapters(context)，适配器。因为SpringMVC中的Handler可以是任意的形式，只要能处理请求就ok，但是Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。如何让固定的Servlet处理方法调用灵活的Handler来进行处理呢？这就是HandlerAdapter要做的事情。<br>Handler是用来干活的工具；HandlerMapping用于根据需要干的活找到相应的工具；HandlerAdapter 是使用工具干活的人。</p>
<p>3、HandlerExceptionResolver<br>initHandlerExceptionResolvers(context)， 其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢？这就需要有一个专门的角色对异常情况进行处理，在SpringMVC中就是HandlerExceptionResolver。具体来说，此组件的作用是根据异常设置ModelAndView，之后再交给render方法进行渲染。</p>
<p>4、ViewResolver<br>initViewResolvers(context)，ViewResolver用来将String类型的视图名和Locale解析为View类型的视图。View是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html（也可能是其它类型） 文件。这里就有两个关键问题：使用哪个模板？用什么技术（规则）填入参数？这其实是ViewResolver 主要要做的工作，ViewResolver需要找到渲染所用的模板和所用的技术（也就是视图的类型）进行渲染，具体的渲染过程则交由不同的视图自己完成。 </p>
<p>5、RequestToViewNameTranslator<br>initRequestToViewNameTranslator(context)，ViewResolver是根据ViewName查找View，但有的 Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了， 如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。 RequestToViewNameTranslator在Spring MVC容器里只可以配置一个，所以所有request到 ViewName的转换规则都要在一个Translator里面全部实现。</p>
<p>6、LocaleResolver<br>initLocaleResolver(context)， 解析视图需要两个参数：一是视图名，另一个是Locale。视图名是处理器返回的，Locale是从哪里来的？这就是LocaleResolver要做的事情。LocaleResolver用于从request解析出Locale，Locale就是zh-cn之类，表示一个区域，有了这个就可以对不同区域的用户显示不同的结果。SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到国际化资源或者主题的时候。</p>
<p>7、ThemeResolver<br>initThemeResolver(context)，用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、如图片、css样式等。SpringMVC的主题也支持国际化，同一个主题不同区域也可以显示不同的风格。SpringMVC中跟主题相关的类有 ThemeResolver、ThemeSource 和Theme。主题是通过一系列资源来具体体现的，要得到一个主题的资源，首先要得到资源的名称，这是ThemeResolver的工作。然后通过主题名称找到对应的主题（可以理解为一个配置）文件，这是 ThemeSource的工作。最后从主题中获取资源就可以了。</p>
<p>8、MultipartResolver<br>initMultipartResolver(context)，用于处理上传请求。处理方法是将普通的request包装成 MultipartHttpServletRequest，后者可以直接调用getFile方法获取File，如果上传多个文件，还可以调用getFileMap得到FileName-&gt;File结构的Map。此组件中一共有三个方法，作用分别是判断是不是上传请求，将request包装成MultipartHttpServletRequest、处理完后清理上传过程中产生的临时资源。</p>
<p>9、FlashMapManager<br>initFlashMapManager(context)，用来管理FlashMap的，FlashMap主要用在redirect中传递参数。</p>
<h2 id="4、Spring-Boot-自动配置原理？"><a href="#4、Spring-Boot-自动配置原理？" class="headerlink" title="4、Spring Boot 自动配置原理？"></a>4、Spring Boot 自动配置原理？</h2><blockquote>
<p>SpringBoot自动配置是指在应用程序启动时，SpringBoot根据classpath路径下的jar包自动配置应用程序所需的一系列bean和组件，从而减少开发者的配置工作，提高开发效率。 </p>
</blockquote>
<p>@Import + @Configuration + Spring spi</p>
<p>自动配置类由各个starter提供，使用@Configuration + @Bean定义配置类，放到META-INF/spring.factories下 </p>
<p>使用Spring spi扫描META-INF/spring.factories下的配置类 </p>
<p>使用@Import导入自动配置类</p>
<p><img src="/../img/1716215283294.png" alt="1716215283294"></p>
<h2 id="5、如何理解-Spring-Boot-中的-Starter"><a href="#5、如何理解-Spring-Boot-中的-Starter" class="headerlink" title="5、如何理解 Spring Boot 中的 Starter"></a>5、如何理解 Spring Boot 中的 Starter</h2><p>使用spring + springmvc使用，如果需要引入mybatis等框架，需要到xml中定义mybatis需要的bean </p>
<p>starter就是定义一个starter的jar包，写一个@Configuration配置类、将这些bean定义在里面，然后在 starter包的META-INF/spring.factories中写入该配置类，springboot会按照约定来加载该配置类 </p>
<p>开发人员只需要将相应的starter包依赖进应用，进行相应的属性配置（使用默认配置时，不需要配置），就可以直接进行代码开发，使用对应的功能了，比如mybatis-spring-boot–starter，springboot-starter-redis </p>
<h2 id="6、什么是嵌入式服务器？为什么要使用嵌入式服务器"><a href="#6、什么是嵌入式服务器？为什么要使用嵌入式服务器" class="headerlink" title="6、什么是嵌入式服务器？为什么要使用嵌入式服务器?"></a>6、什么是嵌入式服务器？为什么要使用嵌入式服务器?</h2><p>节省了下载安装tomcat，应用也不需要再打war包，然后放到webapp目录下再运行 </p>
<p>只需要一个安装了 Java 的虚拟机，就可以直接在上面部署应用程序了 </p>
<p>springboot已经内置了tomcat.jar，运行main方法时会去启动tomcat，并利用tomcat的spi机制加载 springmvc </p>
<h1 id="五、Mybatis"><a href="#五、Mybatis" class="headerlink" title="五、Mybatis"></a>五、Mybatis</h1><h2 id="1、mybatis优缺点"><a href="#1、mybatis优缺点" class="headerlink" title="1、mybatis优缺点"></a>1、mybatis优缺点</h2><p>优点：</p>
<ol>
<li>基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在  XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签， 支持编写动态 SQL 语句，并可重用。</li>
<li>与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；</li>
<li>很好的与各种数据库兼容（ 因为 MyBatis 使用 JDBC 来连接数据库，所以只要JDBC 支持的数据库  MyBatis 都支持）。</li>
<li>能够与 Spring 很好的集成。</li>
<li>提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签， 支持对象关系组件维护。</li>
</ol>
<p>缺点：</p>
<ol>
<li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</li>
<li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>
</ol>
<h2 id="2、MyBatis与Hibernate有哪些不同？"><a href="#2、MyBatis与Hibernate有哪些不同？" class="headerlink" title="2、MyBatis与Hibernate有哪些不同？"></a>2、MyBatis与Hibernate有哪些不同？</h2><p>开发速度的对比：</p>
<p>Hibernate的真正掌握要比Mybatis难些。Mybatis框架相对简单很容易上手，但也相对简陋些。 比起两者的开发速度，不仅仅要考虑到两者的特性及性能，更要根据项目需求去考虑究竟哪一个更适合项目开发，比如：一个项目中用到的复杂查询基本没有，就是简单的增删改查，这样选择hibernate效率就很快了，因为基本的sql语句已经被封装好了，根本不需要你去写sql语句，这就节省了大量的时间，但是对于一个大型项目，复杂语句较多，这样再去选择hibernate就不是一个太好的选择，选择 mybatis就会加快许多，而且语句的管理也比较方便。</p>
<p>开发工作量的对比：</p>
<p>Hibernate和MyBatis都有相应的代码生成工具。可以生成简单基本的DAO层方法。针对高级查询， Mybatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射，可以更专注于业务流程。</p>
<p>sql优化方面：</p>
<p>Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。 Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。</p>
<p>缓存机制对比：</p>
<p>相同点：都可以实现自己的缓存或使用其他第三方缓存方案，创建适配器来完全覆盖缓存行为。<br>不同点：Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是哪种缓存。</p>
<p>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p>
<p>两者比较：因为Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。 </p>
<p>而MyBatis在这一方面，使用二级缓存时需要特别小心。如果不能完全确定数据更新操作的波及范围，避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患。</p>
<p>Hibernate功能强大，数据库无关性好，O/R映射能力强，如果你对Hibernate相当精通，而且对 Hibernate进行了适当的封装，那么你的项目整个持久层代码会相当简单，需要写的代码很少，开发速度很快，非常爽。 </p>
<p>Hibernate的缺点就是学习门槛不低，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡取得平衡，以及怎样用好Hibernate方面需要你的经验和能力都很强才行。</p>
<p>iBATIS入门简单，即学即用，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。</p>
<p>iBATIS的缺点就是框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。</p>
<h2 id="3、-和-的区别是什么？"><a href="#3、-和-的区别是什么？" class="headerlink" title="3、#{}和${}的区别是什么？"></a>3、#{}和${}的区别是什么？</h2><p>#{}是预编译处理、是占位符， ${}是字符串替换、是拼接符。 </p>
<p>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 来赋值； </p>
<p>Mybatis 在处理${}时， 就是把${}替换成变量的值，调用 Statement 来赋值； </p>
<p>#{} 的变量替换是在DBMS 中、变量替换后，#{} 对应的变量自动加上单引号  </p>
<p>${} 的变量替换是在DBMS 外、变量替换后，${} 对应的变量不会加上单引号  使用#{}可以有效的防止 SQL 注入， 提高系统安全性。 </p>
<h2 id="4、简述-Mybatis-的插件运行原理，如何编写一个插件？"><a href="#4、简述-Mybatis-的插件运行原理，如何编写一个插件？" class="headerlink" title="4、简述 Mybatis 的插件运行原理，如何编写一个插件？"></a>4、简述 Mybatis 的插件运行原理，如何编写一个插件？</h2><p>Mybatis 只支持针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这  4 种接口的插件， Mybatis 使用 JDK 的动态代理， 为需要拦截的接口生成代理对象以实现接口方法拦截功能， 每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的  invoke() 方法， 拦截那些你指定需要拦截的方法。</p>
<p>编写插件： 实现 Mybatis 的 Interceptor 接口并复写 intercept()方法， 然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，在配置文件中配置编写的插件。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts({@Signature(type = StatementHandler.class, method = "query", args = </span></span><br><span class="line"><span class="meta">{Statement.class, ResultHandler.class}),</span></span><br><span class="line"><span class="meta"> &nbsp; &nbsp; &nbsp; &nbsp;@Signature(type = StatementHandler.class, method = "update", args = </span></span><br><span class="line"><span class="meta">{Statement.class}),</span></span><br><span class="line"><span class="meta"> &nbsp; &nbsp; &nbsp; &nbsp;@Signature(type = StatementHandler.class, method = "batch", args = { </span></span><br><span class="line"><span class="meta">Statement.class })})</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"></span><br><span class="line">invocation.proceed()执行具体的业务逻辑</span><br></pre></td></tr></tbody></table></figure>



<h1 id="六、MySQL"><a href="#六、MySQL" class="headerlink" title="六、MySQL"></a>六、MySQL</h1><h2 id="1、索引的基本原理"><a href="#1、索引的基本原理" class="headerlink" title="1、索引的基本原理"></a>1、索引的基本原理</h2><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p>
<p>索引的原理：就是把无序的数据变成有序的查询 </p>
<ol>
<li>把创建了索引的列的内容进行排序 </li>
<li>对排序结果生成倒排表 </li>
<li>在倒排表内容上拼上数据地址链 </li>
<li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li>
</ol>
<h2 id="2、Mysql聚簇和非聚簇索引的区别"><a href="#2、Mysql聚簇和非聚簇索引的区别" class="headerlink" title="2、Mysql聚簇和非聚簇索引的区别"></a>2、Mysql聚簇和非聚簇索引的区别</h2><p>都是B+树的数据结构 </p>
<ul>
<li><p>聚簇索引：将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的 </p>
</li>
<li><p>非聚簇索引：叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置再取磁盘查找数据，这个就有点类似一本树的目录，比如我们要找第三章第一节，那我们先在这个目录里面找，找到对应的页码后再去对应的页码看文章。 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">优势：</span><br><span class="line">1、查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询（非覆盖索引的情况下）效率</span><br><span class="line">要高</span><br><span class="line">2、聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的</span><br><span class="line">3、聚簇索引适合用在排序的场合，非聚簇索引不适合</span><br><span class="line">劣势：</span><br><span class="line">1、维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。建议在大量插</span><br><span class="line">入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成</span><br><span class="line">碎片。使用独享表空间可以弱化碎片</span><br><span class="line">2、表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面</span><br><span class="line">更慢，所以建议使用int的auto_increment作为主键</span><br><span class="line">3、如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键</span><br><span class="line">值，会导致非叶子节点占用占用更多的物理空间</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>InnoDB中一定有主键，主键一定是聚簇索引，不手动设置、则会使用unique索引，没有unique索引， 则会使用数据库内部的一个行的隐藏id来当作主键索引。在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引， 辅助索引叶子节点存储的不再是行的物理位置，而是主键值 </p>
<p>MyISM使用的是非聚簇索引，没有聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。 </p>
<p>如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些因为索引所占空间小，这些操作是需要在内存中完成的。</p>
<h2 id="3、Mysql索引的数据结构，各自优势"><a href="#3、Mysql索引的数据结构，各自优势" class="headerlink" title="3、Mysql索引的数据结构，各自优势"></a>3、Mysql索引的数据结构，各自优势</h2><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等， InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。 </p>
<p>B+树：</p>
<p>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。因此，B+树索引被广泛应用于数据库、文件系统等场景。</p>
<p><img src="/../img/1716302207249.png" alt="1716302207249"></p>
<p>哈希索引：</p>
<p> 哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快</p>
<p><img src="/../img/1716302249851.png" alt="1716302249851"></p>
<p>如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；前提是键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据； </p>
<p>如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；</p>
<p>哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）； </p>
<p>哈希索引也不支持多列联合索引的最左匹配规则；</p>
<p>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在哈希碰撞问题。</p>
<h2 id="4、索引设计的原则？"><a href="#4、索引设计的原则？" class="headerlink" title="4、索引设计的原则？"></a>4、索引设计的原则？</h2><p>查询更快、占用空间更小 </p>
<ol>
<li><p>适合索引的列是出现在where子句中的列，或者连接子句中指定的列 </p>
</li>
<li><p>基数较小的表，索引效果较差，没有必要在此列建立索引 </p>
</li>
<li><p>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。 </p>
</li>
<li><p>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。 </p>
</li>
<li><p>定义有外键的数据列一定要建立索引。 </p>
</li>
<li><p>更新频繁字段不适合创建索引 </p>
</li>
<li><p>若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p>
</li>
<li><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。 </p>
</li>
<li><p>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。 </p>
</li>
<li><p>对于定义为text、image和bit的数据类型的列不要建立索引。</p>
</li>
</ol>
<h2 id="5、什么是最左前缀原则？什么是最左匹配原则？"><a href="#5、什么是最左前缀原则？什么是最左匹配原则？" class="headerlink" title="5、什么是最左前缀原则？什么是最左匹配原则？"></a>5、什么是最左前缀原则？什么是最左匹配原则？</h2><p>最左前缀原则是数据库查询优化中的一个概念，特别是在使用复合索引时的一个规则。它要求在查询中使用复合索引时，必须从索引的最左边开始匹配，并且不能跳过中间的列。只有当查询中的过滤条件与索引的最左前缀完全匹配时，索引才能被充分利用。简而言之，最左前缀原则强调在创建和使用复合索引时，最左边的列是优先被考虑的，并且查询条件必须从这里开始匹配。 </p>
<p>这个原则的具体应用包括：</p>
<ul>
<li>当创建了一个包含多个列的复合索引（如A、B、C）时，查询中的过滤条件必须从索引的最左边开始，即A列。</li>
<li>如果第一个字段是范围查询（如大于、小于、介于等），则可能需要单独为该列建立索引。</li>
<li>例如，如果有一个复合索引（A, B, C），那么只有当查询条件从A列开始并包括所有更左边的列时，这个索引才能被有效利用。</li>
</ul>
<p>这个原则的目的是为了提高查询性能，通过确保查询条件能够有效地利用索引来减少数据扫描量。它还强调了在设计数据库和编写查询时，考虑业务需求和查询频率的重要性，以便将最常用于过滤的列放在复合索引的最左边。</p>
<h2 id="6、锁的类型有哪些"><a href="#6、锁的类型有哪些" class="headerlink" title="6、锁的类型有哪些"></a>6、锁的类型有哪些</h2><p>基于锁的属性分类：共享锁、排他锁。</p>
<p>基于锁的粒度分类：行级锁(INNODB)、表级锁(INNODB、MYISAM)、页级锁(BDB引擎)、记录锁、间隙锁、临键锁。 </p>
<p>基于锁的状态分类：意向共享锁、意向排它锁。</p>
<ul>
<li><p>共享锁(Share Lock)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">共享锁又称读锁，简称S锁；当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持</span><br><span class="line">并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>排他锁(exclusive Lock)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排他锁又称写锁，简称X锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取。避免了出现脏数据和脏读的问题。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>表锁</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问；</span><br><span class="line">特点：粒度大，加锁简单，容易冲突；</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>行锁</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问；</span><br><span class="line">特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高；</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>记录锁(Record Lock)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录。</span><br><span class="line">精准条件命中，并且命中的条件字段是唯一索引加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>页锁</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</span><br><span class="line">特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>间隙锁(Gap Lock)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">属于行锁中的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。</span><br><span class="line">范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复读)的事务级别中。</span><br><span class="line">触发条件：防止幻读问题，事务并发的时候，如果没有间隙锁，就会发生如下图的问题，在同一个事务里，A事务的两次查询出的结果会不一样。</span><br><span class="line">比如表里面的数据ID为1,4,5,7,10 ,那么会形成以下几个间隙区间，-n-1区间，1-4区间，7-10区间，10-n区间 （-n代表负无穷大，n代表正无穷大）</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>临建锁(Next-Key Lock)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住</span><br><span class="line">触发条件：范围查询并命中，查询命中了索引。</span><br><span class="line">结合记录锁和间隙锁的特性，临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插入</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁了，你们不能对整个表加共享锁或排它锁了，那么后面需要对整个表加锁的人只需要获取这个状态就知道自己是不是可以对表加锁，避免了对整个索引树的每个节点扫描是否加锁，而这个状态就是意向锁。 </p>
<ul>
<li><p>意向共享锁</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个事务试图对整个表进行加共享锁之前，首先需要获得这个表的意向共享锁。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>意向排他锁</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个事务试图对整个表进行加排它锁之前，首先需要获得这个表的意向排它锁。</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="7、InnoDB存储引擎的锁的算法"><a href="#7、InnoDB存储引擎的锁的算法" class="headerlink" title="7、InnoDB存储引擎的锁的算法"></a>7、InnoDB存储引擎的锁的算法</h2><ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身 </li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<p>相关知识点：</p>
<ol>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key </li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock）A.  将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ol>
<h2 id="8、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#8、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="8、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a>8、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h2><p>在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。 </p>
<p>慢查询的优化首先要搞明白慢的原因是什么？是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？ </p>
<p>所以优化也是针对这三个方向来的，</p>
<ul>
<li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li>
<li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li>
<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li>
</ul>
<h2 id="9、事务的基本特性和隔离级别"><a href="#9、事务的基本特性和隔离级别" class="headerlink" title="9、事务的基本特性和隔离级别"></a>9、事务的基本特性和隔离级别</h2><p>事务基本特性ACID分别是：</p>
<p><strong>原子性</strong>指的是一个事务中的操作要么全部成功，要么全部失败。</p>
<p><strong>一致性</strong>指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，假设A只有90块，支付之前我们数据库里的数据都是符合约束的，但是如果事务执行成功了，我们的数据库数据就破坏约束了，因此事务不能成功，这里我们说事务提供了一致性的保证 </p>
<p><strong>隔离性</strong>指的是一个事务的修改在最终提交前，对其他事务是不可见的。 </p>
<p><strong>持久性</strong>指的是一旦事务提交，所做的修改就会永久保存到数据库中。 </p>
<p>隔离性有4个隔离级别，分别是：</p>
<ul>
<li><p>read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。</p>
<p>用户本来应该读取到id=1的用户age应该是10，结果读取到了其他事务还没有提交的事务，结果读取结果age=20，这就是脏读。 </p>
</li>
<li><p>read commit 读已提交，两次读取结果不一致，叫做不可重复读。</p>
<p>不可重复读解决了脏读的问题，他只会读取已经提交的事务。<br>用户开启事务读取id=1用户，查询到age=10，再次读取发现结果=20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读。</p>
</li>
<li><p>repeatable read 可重复复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。</p>
</li>
<li><p>serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。</p>
</li>
</ul>
<p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因， 前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>
<p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。 </p>
<p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
<h2 id="10、ACID靠什么保证的？"><a href="#10、ACID靠什么保证的？" class="headerlink" title="10、ACID靠什么保证的？"></a>10、ACID靠什么保证的？</h2><p>A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql </p>
<p>C一致性由其他三大特性保证、程序代码要保证业务上的一致性</p>
<p>I隔离性由MVCC来保证 </p>
<p>D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redo log恢复</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InnoDB redo log 写盘，InnoDB 事务进入 prepare 状态。</span><br><span class="line">如果前面 prepare 成功，binlog 写盘，再继续将事务日志持久化到 binlog，如果持久化成功，那么 InnoDB 事务则进入 commit 状态(在 redo log 里面写一个 commit 记录)</span><br></pre></td></tr></tbody></table></figure>

<p>redolog的刷盘会在系统空闲时进行 </p>
<p><img src="/../img/1713693336962.png" alt="1713693336962"></p>
<h2 id="11、MVCC"><a href="#11、MVCC" class="headerlink" title="11、MVCC"></a>11、MVCC</h2><p>Mysql在可重复读隔离级别下如何保证事务较高的隔离性，同样的sql查询语句在一个事务里多次执行查询结果相同，就算其它事务对数据有修改也不会影响当前事务sql语句的查询结果。</p>
<p>这个隔离性就是靠MVCC(<strong>Multi-Version Concurrency Control</strong>)机制来保证的，对一行数据的读和写两个操作默认是不会通过加锁互斥来保证隔离性，避免了频繁加锁互斥，而在串行化隔离级别为了保证较高的隔离性是通过将所有操作加锁互斥来实现的。</p>
<p>Mysql在读已提交和可重复读隔离级别下都实现了MVCC机制。</p>
<h3 id="undo日志版本链与read-view机制详解"><a href="#undo日志版本链与read-view机制详解" class="headerlink" title="undo日志版本链与read view机制详解"></a>undo日志版本链与read view机制详解</h3><p>undo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，Mysql会保留修改前的数据undo回滚日志，并且用两个隐藏字段trx_id和roll_pointer把这些undo日志串联起来形成一个历史记录版本链(见下图，需参考视频里的例子理解)</p>
<p><img src="/../img/1713689247594.png" alt="1713689247594"></p>
<p>在<strong>可重复读隔离级别</strong>，当事务开启，执行任何查询sql时会生成当前事务的<strong>一致性视图read-view，</strong>该视图在事务结束之前永远都不会变化(<strong>如果是读已提交隔离级别在每次执行查询sql时都会重新生成read-view</strong>)，这个视图由执行查询时所有未提交事务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。</p>
<p><strong>版本链比对规则：</strong></p>
<ol>
<li><p>如果 row 的 trx_id 落在绿色部分( trx_id可见的；</p>
</li>
<li><p>如果 row 的 trx_id 落在红色部分( trx_id&gt;max_id )，表示这个版本是由将来启动的事务生成的，是<strong>不可见</strong>的(若 row 的 trx_id 就是当前自己的事务是可见的）；</p>
</li>
<li><p>如果 row 的 trx_id 落在黄色部分(min_id &lt;=trx_id&lt;= max_id)，那就包括两种情况</p>
</li>
</ol>
<p>​     a. 若 row 的 trx_id 在<strong>视图数组</strong>中，表示这个版本是由还没提交的事务生成的，<strong>不可见</strong>(若 row 的 trx_id 就是当前自己的事务是可见的)；</p>
<p>​     b. 若 row 的 trx_id 不在<strong>视图数组</strong>中，表示这个版本是已经提交了的事务生成的，<strong>可见</strong>。</p>
<p><img src="/../img/1713689624681.png" alt="1713689624681"></p>
<p>对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的trx_id，同时在该条记录的头信息（record header）里的（deleted_flag）标记位写上true，来表示当前记录已经被删除，在查询时按照上面的规则查到对应的记录如果delete_flag标记位为true，意味着记录已被删除，则不返回数据。</p>
<h2 id="12、分表后非sharding-key的查询怎么处理，分表后的排序？"><a href="#12、分表后非sharding-key的查询怎么处理，分表后的排序？" class="headerlink" title="12、分表后非sharding_key的查询怎么处理，分表后的排序？"></a>12、分表后非sharding_key的查询怎么处理，分表后的排序？</h2><ol>
<li>可以做一个mapping表，比如这时候商家要查询订单列表怎么办呢？不带user_id查询的话你总不 能扫全表吧？所以我们可以做一个映射关系表，保存商家和用户的关系，查询的时候先通过商家查 询到用户列表，再通过user_id去查询。 </li>
<li>宽表，对数据实时性要求不是很高的场景，比如查询订单列表，可以把订单表同步到离线（实时） 数仓，再基于数仓去做成一张宽表，再基于其他如es提供查询服务。 </li>
<li>数据量不是很大的话，比如后台的一些查询之类的，也可以通过多线程扫表，然后再聚合结果的方式来做。或者异步的形式也是可以的。</li>
</ol>
<p>union</p>
<p>排序字段是唯一索引：</p>
<ul>
<li>首先第一页的查询：将各表的结果集进行合并，然后再次排序</li>
<li>第二页及以后的查询，需要传入上一页排序字段的最后一个值，及排序方式。</li>
<li>根据排序方式，及这个值进行查询。如排序字段date，上一页最后值为3，排序方式降序。查询的时候sql为select … from table where date &lt; 3 order by date desc limit 0,10。这样再将几个表的结果合并排序即可。</li>
</ul>
<h2 id="13、MySQL主从同步原理"><a href="#13、MySQL主从同步原理" class="headerlink" title="13、MySQL主从同步原理"></a>13、MySQL主从同步原理</h2><p>mysql主从同步的过程：</p>
<p>Mysql的主从复制中主要有三个线程： <code>master（binlog dump thread）</code>、<code>slave（I/O thread 、SQL  thread） </code>，Master一条线程和Slave中的两条线程。</p>
<ul>
<li>主节点binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog 是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。</li>
<li>主节点 log dump 线程，当 binlog 有变动时，log dump线程读取其内容并发送给从节点。 </li>
<li>从节点 I/O线程接收 binlog 内容，并将其写入到 relay log 文件中。 </li>
<li>从节点的SQL 线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库的一致性。</li>
</ul>
<p>注：主从节点使用 binglog 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从 position 的位置发起同步。</p>
<p>由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。</p>
<p><strong>全同步复制</strong> </p>
<p>主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。</p>
<p><strong>半同步复制</strong></p>
<p>和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。</p>
<h2 id="14、简述MyISAM和InnoDB的区别"><a href="#14、简述MyISAM和InnoDB的区别" class="headerlink" title="14、简述MyISAM和InnoDB的区别"></a>14、简述MyISAM和InnoDB的区别</h2><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>不支持事务，但是每次查询都是原子的；</p>
<p>支持表级锁，即每次操作是对整个表加锁；</p>
<p>存储表的总行数； </p>
<p>一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；</p>
<p>采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。</p>
<h3 id="InnoDb"><a href="#InnoDb" class="headerlink" title="InnoDb"></a>InnoDb</h3><p>支持ACID的事务，支持事务的四种隔离级别； </p>
<p>支持行级锁及外键约束：因此可以支持写并发； </p>
<p>不存储总行数；</p>
<p>一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多 个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操 作系统文件大小的限制； </p>
<p>主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅 索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时， 为维持B+树结构，文件的大调整。</p>
<h2 id="15、简述mysql中索引类型及对数据库的性能的影响"><a href="#15、简述mysql中索引类型及对数据库的性能的影响" class="headerlink" title="15、简述mysql中索引类型及对数据库的性能的影响"></a>15、简述mysql中索引类型及对数据库的性能的影响</h2><p>普通索引：允许被索引的数据列包含重复的值。 </p>
<p>唯一索引：可以保证数据记录的唯一性。</p>
<p>主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。</p>
<p>联合索引：索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引。  </p>
<p>全文索引：通过建立倒排索引 ,可以极大的提升检索效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术。可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引。</p>
<p>索引可以极大的提高数据的查询速度。 </p>
<p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 </p>
<p>但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件</p>
<p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都会跟着变。</p>
<h2 id="16、mysql执行计划怎么看"><a href="#16、mysql执行计划怎么看" class="headerlink" title="16、mysql执行计划怎么看"></a>16、mysql执行计划怎么看</h2><p>执行计划就是sql的执行查询的顺序，以及如何使用索引查询，返回的结果集的行数 </p>
<p>EXPLAIN SELECT * from A where X=? and Y=?</p>
<p><img src="/../img/1716395977214.png" alt="1716395977214"></p>
<ol>
<li><p>id ：是一个有顺序的编号，是查询的顺序号，有几个 select 就显示几行。id的顺序是按 select 出现的顺序增长的。id列的值越大执行优先级越高越先执行，id列的值相同则从上往下执行，id列的值为 NULL最后执行。</p>
</li>
<li><p>selectType 表示查询中每个select子句的类型</p>
<p>SIMPLE： 表示此查询不包含 UNION 查询或子查询 </p>
<p>PRIMARY： 表示此查询是最外层的查询（包含子查询） </p>
<p>SUBQUERY： 子查询中的第一个 SELECT</p>
<p>UNION： 表示此查询是 UNION 的第二或随后的查询 </p>
<p>DEPENDENT UNION： UNION 中的第二个或后面的查询语句, 取决于外面的查询 </p>
<p>UNION RESULT, UNION 的结果</p>
<p>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果. </p>
<p>DERIVED：衍生，表示导出表的SELECT（FROM子句的子查询） </p>
</li>
<li><p>table：表示该语句查询的表</p>
</li>
<li><p>type：优化sql的重要字段，也是我们判断sql性能和优化程度重要指标。他的取值类型范围：</p>
<p>const：通过索引一次命中，匹配一行数据</p>
<p>system: 表中只有一行记录，相当于系统表；</p>
<p>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配</p>
<p>ref: 非唯一性索引扫描,返回匹配某个值的所有 </p>
<p>range: 只检索给定范围的行，使用一个索引来选择行，一般用于between、&lt;、&gt;；</p>
<p>index: 只遍历索引树；</p>
<p>ALL: 表示全表扫描，这个类型的查询是性能最差的查询之一。 那么基本就是随着表的数量增多， 执行效率越慢。</p>
</li>
</ol>
<p><strong>执行效率： ALL &lt; index &lt; range&lt; ref &lt; eq_ref &lt; const &lt; system。最好是避免ALL和index</strong></p>
<ol start="5">
<li><p>possible_keys：它表示Mysql在执行该sql语句的时候，可能用到的索引信息，仅仅是可能，实际不一定会用到。</p>
</li>
<li><p>key：此字段是 mysql 在当前查询时所真正使用到的索引。 他是possible_keys的子集 </p>
</li>
<li><p>key_len：表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用，这也是我们优化sql时，评估索引的重要指标</p>
</li>
<li><p>rows：mysql 查询优化器根据统计信息，估算该sql返回结果集需要扫描读取的行数，这个值相当重要，索引优化之后，扫描读取的行数越多，说明索引设置不对，或者字段传入的类型之类的问题，说明要优化空间越大</p>
</li>
<li><p>filtered：返回结果的行占需要读到的行(rows列的值)的百分比，就是百分比越高，说明需要查询到数据越准确， 百分比越小，说明查询到的数据量大，而结果集很少</p>
</li>
<li><p>extra</p>
<p>using filesort ：表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有  using filesort都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。 </p>
<p>using index：覆盖索引扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往往说明性能不错。</p>
<p>using temporary：查询有使用临时表, 一般出现于排序，分组和多表 join 的情况， 查询效率不高，建议优化。</p>
<p>using where ：sql使用了where过滤,效率较高。</p>
</li>
</ol>
<h1 id="七、Redis"><a href="#七、Redis" class="headerlink" title="七、Redis"></a>七、Redis</h1><h2 id="1、RDB和AOF机制"><a href="#1、RDB和AOF机制" class="headerlink" title="1、RDB和AOF机制"></a>1、RDB和AOF机制</h2><p>RDB：Redis DataBase </p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p><strong>优点</strong></p>
<p>1、整个Redis数据库将只包含一个文件dump.rdb，方便持久化。</p>
<p>2、容灾性好，方便备份。</p>
<p>3、性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能。</p>
<p>4、相对于数据集大时，比AOF的启动效率更高。</p>
<p><strong>缺点：</strong> </p>
<p>1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</p>
<p>2、由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。 </p>
<p>AOF：Append Only File</p>
<p>以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录</p>
<ul>
<li><strong>优点：</strong></li>
</ul>
<p>1、数据安全，Redis中提供了3种同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。</p>
<p>2、通过 append 模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redischeck-aof 工具解决数据一致性问题。</p>
<p>3、AOF 机制的 rewrite 模式。定期对AOF文件进行重写，以达到压缩的目的。</p>
<ul>
<li><strong>缺点：</strong></li>
</ul>
<p>1、AOF 文件比 RDB 文件大，且恢复速度慢。 </p>
<p>2、数据集大的时候，比 rdb 启动效率低。 </p>
<p>3、运行效率没有RDB高</p>
<p>AOF文件比RDB更新频率高，优先使用AOF还原数据。 </p>
<p>AOF比RDB更安全也更大 。</p>
<p>RDB性能比AOF好 。</p>
<p>如果两个都配了优先加载AOF。</p>
<h2 id="2、Redis的过期键的删除策略"><a href="#2、Redis的过期键的删除策略" class="headerlink" title="2、Redis的过期键的删除策略"></a>2、Redis的过期键的删除策略</h2><p>Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当 Redis中缓存的key过期了，Redis如何处理。 </p>
<ul>
<li><strong>惰性过期</strong>：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。 </li>
<li><strong>定期过期</strong>：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时， 可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</li>
</ul>
<p>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。) </p>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。 </p>
<h2 id="3、Redis线程模型、单线程快的原因"><a href="#3、Redis线程模型、单线程快的原因" class="headerlink" title="3、Redis线程模型、单线程快的原因"></a>3、Redis线程模型、单线程快的原因</h2><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器 file event handler。这个文件事件处理器，它是单线程的，所以 Redis 才叫做单线程的模型，它采用IO多路复用机制来同时监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了 Redis 内部的线程模型的简单性。</p>
<p>文件事件处理器的结构包含4个部分：多个Socket、IO多路复用程序、文件事件分派器以及事件处理器（命令请求处理器、命令回复处理器、连接应答处理器等）。 多个 Socket 可能并发的产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个 Socket，会将 Socket 放入一个队列中排队，每次从队列中取出一个Socket 给事件分派器，事件分派器把 Socket 给对应的事件处理器。 然后一个 Socket 的事件处理完之后，IO多路复用程序才会将队列中的下一个 Socket 给事件分派器。文件事件分派器会根据每个 Socket 当前产生的事件，来选择对应的事件处理器来处理。</p>
<p>单线程快的原因： </p>
<p>1）纯内存操作</p>
<p>2）核心是基于非阻塞的IO多路复用机制</p>
<p>3）单线程反而避免了多线程的频繁上下文切换带来的性能问题</p>
<h2 id="4、简述Redis事务实现"><a href="#4、简述Redis事务实现" class="headerlink" title="4、简述Redis事务实现"></a>4、简述Redis事务实现</h2><h3 id="1、事务开始"><a href="#1、事务开始" class="headerlink" title="1、事务开始"></a>1、事务开始</h3><p>MULTI命令的执行，标识着一个事务的开始。MULTI命令会将客户端状态的<code>flags</code>属性中打开<code>REDIS_MULTI</code>标识来完成的。</p>
<h3 id="2、命令入队"><a href="#2、命令入队" class="headerlink" title="2、命令入队"></a>2、命令入队</h3><p>当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客户端发送的命令为MULTI、EXEC、WATCH、DISCARD中的一个，立即执行这个命令，否则将命令放入一个事务队列里面，然后向客户端返回<code>QUEUED</code>回复</p>
<ul>
<li><p>如果客户端发送的命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中一个，那么服务器立即执行这个命令。</p>
</li>
<li><p>如果客户端发送的是四个命令以外的其他命令，那么服务器并不立即执行这个命令。</p>
<p>首先检查此命令的格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属性关闭 REDIS_MULTI 标识，并且返回错误信息给客户端。</p>
<p>如果正确，将这个命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复</p>
</li>
</ul>
<p>事务队列是按照FIFO的方式保存入队的命令</p>
<h3 id="3、事务执行"><a href="#3、事务执行" class="headerlink" title="3、事务执行"></a>3、事务执行</h3><p>客户端发送 EXEC 命令，服务器执行 EXEC 命令逻辑。</p>
<ul>
<li>如果客户端状态的 flags 属性不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者  REDIS_DIRTY_EXEC 标识，那么就直接取消事务的执行。</li>
<li>否则客户端处于事务状态（flags 有 REDIS_MULTI 标识），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返回给客户端；</li>
</ul>
<p>redis 不支持事务回滚机制，但是它会检查每一个事务中的命令是否错误。</p>
<p>Redis 事务不支持检查那些程序员自己逻辑错误。例如对 String 类型的数据库键执行对 HashMap 类型的操作！</p>
<ul>
<li>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC 命令。</li>
<li>MULTI命令用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li>
<li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil。</li>
<li>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态中退出。</li>
<li>UNWATCH命令可以取消watch对所有key的监控。</li>
</ul>
<h2 id="5、Redis集群方案"><a href="#5、Redis集群方案" class="headerlink" title="5、Redis集群方案"></a>5、Redis集群方案</h2><p>主从</p>
<p><strong>哨兵模式：</strong></p>
<p>sentinel，哨兵是 redis 集群中非常重要的一个组件，主要有以下功能：</p>
<ul>
<li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。 </li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li>
</ul>
<p>哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<ul>
<li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的</li>
<li>哨兵通常需要 3 个实例，来保证自己的健壮性。 </li>
<li>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</li>
<li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>
</ul>
<p>Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。</p>
<p><strong>方案说明</strong></p>
<ul>
<li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了 16384 个槽位</li>
<li>每份数据分片会存储在多个互为主从的多节点上</li>
<li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步) </li>
<li>同一分片多个节点间的数据不保持强一致性</li>
<li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点 </li>
<li>扩容时需要需要把旧节点的数据迁移一部分到新节点</li>
</ul>
<p>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是加1w 的端口号，比如 16379。</p>
<p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的通信，用来进行故障检测、配置更新、 故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<p><strong>优点</strong></p>
<ul>
<li>无中心架构，支持动态扩容，对业务透明</li>
<li>具备Sentinel的监控和自动Failover(故障转移)能力</li>
<li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可 </li>
<li>高性能，客户端直连redis服务，免去了proxy代理的损耗</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>运维也很复杂，数据迁移需要人工干预 </li>
<li>只能使用0号数据库</li>
<li>不支持批量操作(pipeline管道操作)</li>
<li>分布式逻辑和存储模块耦合等</li>
</ul>
<p>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的 ShardedJedisPool </p>
<p><strong>优点</strong></p>
<p>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强</p>
<p><strong>缺点</strong></p>
<p>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</p>
<p>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化</p>
<h2 id="6、redis-主从复制的核心原理"><a href="#6、redis-主从复制的核心原理" class="headerlink" title="6、redis 主从复制的核心原理"></a>6、redis 主从复制的核心原理</h2><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p>当从节点连接上主节点后，会发送一个PSYNC命令给主节点请求复制数据。</p>
<p>主节点接收到PSYNC命令后，会通过bgsave命令进行数据持久化，生成RDB快照文件。在持久化期间，主节点持续接收客户端请求，将修改操作缓存到内存中。持久化完成后，主节点将RDB文件发送给从节点，从节点清空旧数据并加载RDB文件数据。加载完成后，主节点再将之前缓存在内存的操作命令发送给从节点，从节点再将它执行。</p>
<p>当主节点与从节点之间的连接由于某些原因而断开时，从节点会自动重连主节点。</p>
<p>如果主节点收到了多个从节点的并发连接请求，它只会持久化一次，而不会每个连接一次，然后把一份RDB文件发送给多个并发连接的从节点。</p>
<p><img src="/../img/quanliangfuzhi.png" alt="quanliangfuzhi"></p>
<h3 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h3><p>redis2.8版本开始，redis改用可以支持部分数据复制的命令PSYNC去同步数据，能够实现在网络连接断开重连后只进行部分数据复制(<strong>断电续传</strong>)。</p>
<p>主节点会在内存中维护一个缓存队列，缓存最近一段时间的数据，主节点和从节点都维护了复制的数据下标和主节点的进程id，因此，当网络连接断开后，从节点会从所记录的数据下标开始，请求主节点继续进行未完成的复制。如果主节点的进程id变了，或从节点数据下标已经不在主节点的缓存队列里了，那么将会进行一次全量数据的复制。</p>
<p><img src="/../img/bufenshujufuzhi.png" alt="bufenshujufuzhi"></p>
<h2 id="7、缓存雪崩、缓存穿透、缓存击穿"><a href="#7、缓存雪崩、缓存穿透、缓存击穿" class="headerlink" title="7、缓存雪崩、缓存穿透、缓存击穿"></a>7、缓存雪崩、缓存穿透、缓存击穿</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者因为某种原因使Redis服务宕机，导致大量请求到达数据库，带来巨大压力。 </p>
<p>预防和解决缓存雪崩问题，可以从以下三个方面进行着手。</p>
<p>1）<strong>保证缓存层服务高可用性</strong>，比如使用Redis Sentinel或Redis Cluster。 </p>
<p>2）<strong>依赖隔离组件为后端限流熔断并降级</strong>。比如使用Sentinel或Hystrix限流降级组件。比如服务降级，我们可以针对不同的数据采取不同的处理方式。当业务应用访问的是非核心数据（例如电商商品属性，用户信息等）时，暂时停止从缓存中查询这些数据，而是直接返回预定义的默认降级信息、空值或是错误提示信息；当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。</p>
<p>3） <strong>提前演练</strong>。 在项目上线前，演练缓存层宕掉后， 应用以及后端的负载情况以及可能出现的问题， 在此基础上做一些预案设定。</p>
<p>4）<strong>采用多级缓存架构</strong>，在redis缓存层上面可以再加一层本地缓存，本地缓存直接从JVM内存中获取数据，几乎没有IO开销，极大地保护了redis缓存层，防止缓存雪崩。</p>
<p>5）给不同key的过期时间添加随机值。</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>缓存穿透</strong>是指查询一个根本不存在的数据，缓存层和存储层都不会命中，通常出于容错的考虑，如果从存储层查不到数据则不写入缓存层。</p>
<p>缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。</p>
<p>造成缓存穿透的基本原因有两个：<br>第一， 自身业务代码或者数据出现问题。<br>第二， 一些恶意攻击、 爬虫等造成大量空命中。<br>缓存穿透问题解决方案：</p>
<ul>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截； </li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击 </li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿</strong>问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。常见的解决方案有： </p>
<ol>
<li>互斥锁。缺点：查询速度会变慢。会有大量请求阻塞等待缓存重建。</li>
<li>异步重建缓存。缺点：会有短时间脏数据情况的出现。</li>
<li>热点key永不过期，主动更新。缺点：会导致内存一直占用。</li>
<li>接口限流。</li>
</ol>
<h1 id="八、分布式-x2F-微服务"><a href="#八、分布式-x2F-微服务" class="headerlink" title="八、分布式/微服务"></a>八、分布式/微服务</h1><h2 id="1、CAP理论，BASE理论"><a href="#1、CAP理论，BASE理论" class="headerlink" title="1、CAP理论，BASE理论"></a>1、CAP理论，BASE理论</h2><p><strong>Consistency (一致性)：</strong><br>即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致。<br>对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。<br>从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。</p>
<p>**Availability (可用性): **<br>即服务一直可用，而且是正常响应时间。系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。</p>
<p><strong>Partition Tolerance (分区容错性):</strong><br>即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。</p>
<p><strong>CP和AP</strong>：分区容错是必须保证的，当发生网络分区的时候，如果要继续服务，那么强一致性和可用性只能 2 选 1 </p>
<p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）</p>
<p>BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 </p>
<p>基本可用： </p>
<ul>
<li>响应时间上的损失: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。 </li>
<li>系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li>
</ul>
<p>软状态：数据同步允许一定的延迟</p>
<p>最终一致性：系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态，不要求实时。</p>
<h2 id="2、负载均衡算法、类型"><a href="#2、负载均衡算法、类型" class="headerlink" title="2、负载均衡算法、类型"></a>2、负载均衡算法、类型</h2><h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><p>**1、轮询法 **<br>将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</p>
<p><strong>2、随机法</strong><br>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。 </p>
<p><strong>3、源地址哈希法</strong><br>源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</p>
<p><strong>4、加权轮询法</strong><br>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p>
<p><strong>5、加权随机法</strong><br>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p>
<p><strong>6、最小连接数法</strong><br>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>DNS 方式实现负载均衡</p>
<p>硬件负载均衡：F5 和 A10 </p>
<p>软件负载均衡：</p>
<p><code>Nginx</code>、<code>HAproxy</code>、<code>LVS</code>。其中的区别：</p>
<ul>
<li>Nginx ：七层负载均衡，支持 HTTP、E-mail 协议，同时也支持 4 层负载均衡；</li>
<li>HAproxy ：支持七层规则的，性能也很不错。OpenStack 默认使用的负载均衡软件就是  HAproxy；</li>
<li>LVS ：运行在内核态，性能是软件负载均衡中最高的，严格来说工作在三层，所以更通用一些，适用各种应用服务。</li>
</ul>
<h2 id="3、分布式架构下，Session共享有什么方案"><a href="#3、分布式架构下，Session共享有什么方案" class="headerlink" title="3、分布式架构下，Session共享有什么方案"></a>3、分布式架构下，Session共享有什么方案</h2><p><strong>1、采用无状态服务，抛弃session</strong></p>
<p>在采用无状态服务的架构中，服务端不保存用户的会话状态，而是将用户的状态信息保存在客户端，比如使用 JWT（JSON Web Token）等机制。这样每个请求都包含了用户的身份信息，服务端可以根据请求中的身份信息来判断用户的权限和状态。 </p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>简化服务端逻辑：</strong>无状态服务无需保存会话状态，服务端逻辑更加简单，可以实现水平扩展。</li>
<li><strong>易于扩展：</strong>由于服务端无需保存状态信息，因此可以很方便地实现负载均衡和水平扩展。</li>
<li><strong>降低系统开销：</strong>无状态服务避免了在服务端保存会话状态的开销，减少了系统的资源消耗。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>安全性考虑：</strong>由于会话状态保存在客户端，可能会被篡改或盗用，因此需要额外的安全措施来保护用户的身份信息。</li>
<li><strong>无法保存会话状态：</strong>无状态服务无法保存会话状态，适用于不需要保存会话状态的场景，但对于某些应用场景可能会存在一些限制。</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li><strong>RESTful API 接口：</strong> 无状态服务适用于 RESTful API 接口等无需保存会话状态的场景。</li>
<li><strong>微服务架构：</strong> 微服务架构中的服务通常是无状态的，采用无状态服务可以更好地支持微服务架构。</li>
</ul>
<p><strong>2、存入cookie（有安全风险）</strong></p>
<p>在分布式架构中，为了实现会话状态的共享，一种常见的方案是将会话标识信息存储在用户的 Cookie 中，然后通过客户端将该 Cookie 传递给不同的服务节点。 </p>
<p><strong>方案介绍：</strong> 将会话标识信息（如 Session ID）存储在用户的 Cookie 中，服务端根据请求中的 Cookie 来识别用户的会话状态。 </p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>简单方便：</strong> 使用 Cookie 存储会话标识信息简单方便，无需额外的存储服务。</li>
<li><strong>无状态服务：</strong> 服务端无需保存会话状态，可实现无状态服务，便于水平扩展和负载均衡。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>安全风险：</strong> 将会话标识信息存储在 Cookie 中存在被窃取或篡改的风险，可能导致会话劫持等安全问题。</li>
<li><strong>跨域限制：</strong> 跨域请求时，Cookie 可能受到限制，影响会话共享的有效性。</li>
<li><strong>存储限制：</strong> Cookie 存储容量有限，无法存储大量的会话数据。</li>
</ul>
<p><strong>安全防范措施：</strong> </p>
<ul>
<li>加密和签名： 对存储在 Cookie 中的会话标识信息进行加密和签名，增强安全性。</li>
<li>HttpOnly 属性： 设置 Cookie 的 HttpOnly 属性，防止 JavaScript 访问，减少 XSS 攻击风险。</li>
<li>Secure 属性： 设置 Cookie 的 Secure 属性，仅在 HTTPS 连接中传输，增强安全性。</li>
</ul>
<p><strong>3、服务器之间进行 Session 同步</strong></p>
<p>在分布式架构中，为了确保每个服务器上都有完整的 Session 信息，一种方案是通过服务器之间进行 Session 同步，即将 Session 数据在多个服务器之间同步复制，以实现会话状态的共享。 </p>
<p><strong>方案介绍：</strong>服务器之间进行 Session 同步，将 Session 数据在多个服务器之间进行复制同步，确保每个服务器上都有完整的 Session 信息。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>保证数据完整性：</strong> 通过服务器之间的同步复制，可以确保每个服务器上都有完整的 Session 信息，提高系统的可靠性。</li>
<li><strong>无需额外存储：</strong> 无需额外的存储服务，只需在服务器之间进行数据同步。</li>
</ul>
<p> <strong>缺点：</strong></p>
<ul>
<li><strong>延迟和同步失败：</strong> 当服务器数量较多时，同步会面临延迟和同步失败的问题，特别是在网络不稳定或服务器负载高的情况下。</li>
<li><strong>复杂度高：</strong> 需要实现复杂的同步机制和算法，增加系统的复杂度和维护成本。</li>
<li><strong>一致性难以保证：</strong> 多个服务器之间的同步可能存在一致性问题，如数据冲突、数据丢失等。</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li><strong>小规模系统：</strong> 适用于服务器数量较少、网络稳定的小规模系统。</li>
<li><strong>对一致性要求不高的场景：</strong> 对会话数据的一致性要求不高的场景，如用户状态不频繁变化的应用场景。</li>
</ul>
<p><strong>安全防范措施：</strong></p>
<ul>
<li><strong>数据加密：</strong> 在数据同步过程中对会话数据进行加密保护，防止数据被窃取或篡改。</li>
<li><strong>数据校验：</strong> 在数据同步过程中对数据进行校验和验证，确保数据的完整性和一致性。</li>
</ul>
<p><strong>4、 IP 绑定策略</strong></p>
<p>使用 IP 绑定策略，通过 Nginx 或其他复杂均衡软硬件，限制同一个 IP 只能在指定的同一台服务器上访问，从而实现 Session 的共享。 </p>
<p><strong>方案介绍：</strong> 通过配置 Nginx 或其他负载均衡软硬件，实现 IP 绑定策略，将同一个 IP 的请求定向到同一台服务器，以实现 Session 的共享。 </p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>安全性高：</strong> 通过 IP 绑定策略可以有效防止会话劫持等安全威胁。</li>
<li><strong>会话保持：</strong> 同一用户的请求会被定向到同一台服务器，可以保持用户会话的连续性和一致性。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>失去负载均衡意义：</strong> 使用 IP 绑定策略会失去负载均衡的意义，无法充分利用服务器资源进行负载均衡，增加了单点故障的风险。</li>
<li><strong>影响用户体验：</strong> 当指定的服务器挂掉时，同一批用户的访问将受到影响，可能导致用户体验下降。</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li><strong>对安全性要求较高：</strong> 适用于对安全性要求较高的场景，如金融、支付等领域。</li>
<li><strong>特定业务需求：</strong> 适用于特定业务需求，需要保持用户会话的连续性和一致性的场景。</li>
</ul>
<p><strong>安全防范措施：</strong></p>
<ul>
<li><strong>SSL 加密：</strong> 在 IP 绑定的基础上使用 SSL 加密保护通信数据，增加安全性。</li>
<li><strong>定期更新 IP 绑定策略：</strong> 定期更新 IP 绑定策略，根据实际情况调整和优化。</li>
</ul>
<p><strong>5、使用 Redis 存储</strong><br>将 Session 存储到 Redis 中，通过 Redis 实现会话状态的共享和管理，虽然增加了架构的复杂性，但带来的好处也是非常大的。 </p>
<p><strong>方案介绍：</strong> 将 Session 数据存储到 Redis 中，各个服务器通过访问共享的 Redis 服务来获取和更新 Session 数据，从而实现会话状态的共享和管理。 </p>
<p><strong>优点：</strong></p>
<ul>
<li>实现了 Session 共享： 通过 Redis 存储 Session 数据，实现了会话状态的共享，各个服务器之间可以共享同一份会话数据。</li>
<li>水平扩展： Redis 支持水平扩展，可以通过增加 Redis 服务器来提高系统的吞吐量和容量。</li>
<li>服务器重启不丢失： Redis 可以持久化存储 Session 数据，即使服务器重启也不会丢失会话数据，提高了系统的可靠性。</li>
<li>跨平台共享： 不仅可以实现跨服务器的 Session 共享，还可以实现跨平台（如网页端和 APP 端）的 Session 共享。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>增加架构复杂性： 引入 Redis 存储 Session 增加了架构的复杂性，需要额外的配置和管理。</li>
<li>访问 Redis 延迟： 每次访问 Session 都需要通过访问 Redis 来获取和更新数据，可能会增加访问延迟。</li>
<li>需要考虑失效机制： 需要注意设置合适的 Session 在 Redis 中的失效机制，避免过期 Session 占用过多内存。</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li><strong>需要跨服务器共享 Session 的场景：</strong> 适用于需要多个服务器共享 Session 数据的场景。</li>
<li><strong>需要跨平台共享 Session 的场景：</strong> 适用于需要网页端和 APP 端等不同平台共享 Session 数据的场景。</li>
</ul>
<p><strong>安全防范措施：</strong></p>
<ul>
<li><strong>数据加密：</strong>对存储在 Redis 中的会话数据进行加密保护，防止数据被窃取或篡改。</li>
<li><strong>访问控制：</strong>对 Redis 服务进行访问控制，限制只有授权的服务器可以访问。</li>
</ul>
<p><strong>6、总结</strong> </p>
<p>在分布式架构下，Session 共享是保证用户会话状态一致性的关键问题之一。每种方案都有其优缺点，适用于不同的场景和需求。在选择合适的方案时，需要综合考虑安全性、性能、可靠性等因素，并根据实际情况进行权衡和取舍。</p>
<h2 id="4、简述你对RPC、RMI的理解"><a href="#4、简述你对RPC、RMI的理解" class="headerlink" title="4、简述你对RPC、RMI的理解"></a>4、简述你对RPC、RMI的理解</h2><p>RPC：在本地调用远程的函数，远程过程调用，可以跨语言实现 httpClient</p>
<p>RMI：远程方法调用，java中用于实现RPC的一种机制，RPC的java版本，是J2EE的网络调用机制，跨 JVM调用对象的方法，面向对象的思维方式</p>
<p>直接或间接实现接口 java.rmi.Remote 成为存在于服务器端的远程对象，供客户端访问并提供一定的服务</p>
<p>远程对象必须实现java.rmi.server.UniCastRemoteObject类，这样才能保证客户端访问获得远程对象时，该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端，此时客户端所获得的这个拷贝称为“存根”，而服务器端本身已存在的远程对象则称之为“骨架”。其实此时的存根是客户端的一个代理，用于与服务器端的通信，而骨架也可认为是服务器端的一个代理，用于接收客户端的请求之后调用远程方法来响应客户端的请求。  </p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IService</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> {</span><br><span class="line"> &nbsp; &nbsp;String <span class="title function_">service</span><span class="params">(String content)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">IService</span> {</span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">private</span> String name;</span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">public</span> <span class="title function_">ServiceImpl</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="built_in">this</span>.name = name;</span><br><span class="line"> &nbsp; }</span><br><span class="line"> &nbsp; &nbsp;<span class="meta">@Override</span></span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">public</span> String <span class="title function_">service</span><span class="params">(String content)</span> {</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">return</span> <span class="string">"server &gt;&gt; "</span> + content;</span><br><span class="line"> &nbsp; }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> {</span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">try</span> {</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="type">IService</span> <span class="variable">service02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceImpl</span>(<span class="string">"service02"</span>);</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="type">Context</span> <span class="variable">namingContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;namingContext.rebind(<span class="string">"rmi://127.0.0.1/service02"</span>, service02);</span><br><span class="line"> &nbsp; &nbsp; &nbsp; } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;e.printStackTrace();</span><br><span class="line"> &nbsp; &nbsp; &nbsp; }</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(<span class="string">"000000！"</span>);</span><br><span class="line"> &nbsp; }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">"rmi://127.0.0.1/"</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Context</span> <span class="variable">namingContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">            <span class="type">IService</span> <span class="variable">service02</span> <span class="operator">=</span> (IService) namingContext.lookup(url + </span><br><span class="line">                                                                 <span class="string">"service02"</span>);</span><br><span class="line">            <span class="type">Class</span> <span class="variable">stubClass</span> <span class="operator">=</span> service02.getClass();</span><br><span class="line">            System.out.println(service02 + <span class="string">" is "</span> + stubClass.getName());</span><br><span class="line">            <span class="comment">//com.sun.proxy.$Proxy0</span></span><br><span class="line"></span><br><span class="line">            Class[] interfaces = stubClass.getInterfaces();</span><br><span class="line">            <span class="keyword">for</span> (Class c : interfaces) {</span><br><span class="line">                System.out.println(<span class="string">"implement"</span> + c.getName() + <span class="string">" interface"</span>);</span><br><span class="line">            }</span><br><span class="line">            System.out.println(service02.service(<span class="string">"hello"</span>));</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="5、分布式id生成方案"><a href="#5、分布式id生成方案" class="headerlink" title="5、分布式id生成方案"></a>5、分布式id生成方案</h2><ul>
<li><p>uuid</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、当前日期和时间 &nbsp; &nbsp;时间戳 &nbsp; &nbsp;</span><br><span class="line">2、时钟序列。 &nbsp; 计数器</span><br><span class="line">3、全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。</span><br><span class="line"> &nbsp; &nbsp;</span><br><span class="line">优点：代码简单，性能好（本地生成，没有网络消耗），保证唯一（相对而言，重复概率极低可以忽略）</span><br><span class="line">缺点： &nbsp;</span><br><span class="line">	每次生成的ID都是无序的，而且不是全数字，且无法保证趋势递增。</span><br><span class="line"> &nbsp; &nbsp;UUID生成的是字符串，字符串存储性能差，查询效率慢，写的时候由于不能产生顺序的append操作，需要进行insert操作，导致频繁的页分裂，这种操作在记录占用空间比较大的情况下，性能下降比较大，还会增加读取磁盘次数 </span><br><span class="line"> &nbsp; &nbsp;UUID长度过长，不适用于存储，耗费数据库性能。</span><br><span class="line"> &nbsp; &nbsp;ID无一定业务含义，可读性差。</span><br><span class="line"> &nbsp; &nbsp;有信息安全问题，有可能泄露mac地址</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>数据库自增序列</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">单机模式： </span><br><span class="line">优点：</span><br><span class="line"> &nbsp; &nbsp; 实现简单，依靠数据库即可，成本小。</span><br><span class="line"> &nbsp; &nbsp; ID数字化，单调自增，满足数据库存储和查询性能。</span><br><span class="line"> &nbsp; &nbsp; 具有一定的业务可读性。（结合业务code）</span><br><span class="line">缺点：</span><br><span class="line"> &nbsp; &nbsp; 强依赖DB，存在单点问题，如果数据库宕机，则业务不可用。</span><br><span class="line"> &nbsp; &nbsp; DB生成ID性能有限，单点数据库压力大，无法扛高并发场景。</span><br><span class="line"> &nbsp; &nbsp; 信息安全问题，比如暴露订单量，url查询改下id查到别人的订单。</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><br><span class="line">数据库高可用：多主模式做负载，基于序列的起始值和步长设置，不同的初始值，相同的步长，步长大于节点数</span><br><span class="line">优点：</span><br><span class="line"> &nbsp; 解决了ID生成的单点问题，同时平衡了负载。</span><br><span class="line">缺点：</span><br><span class="line">    系统扩容困难：系统定义好步长之后，增加机器之后调整步长困难。</span><br><span class="line">	数据库压力大：每次获取一个ID都必须读写一次数据库。</span><br><span class="line">	主从同步的时候：电商下单-&gt;支付insert master db select数据 ，因为数据同步延迟导致</span><br><span class="line">查不到这个数据。加cache(不是最好的解决方式)数据要求比较严谨的话查master主库。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>Leaf-segment</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">采用每次获取一个ID区间段的方式来解决，区间段用完之后再去数据库获取新的号段，这样一来可以大大减轻数据库的压力</span><br><span class="line">核心字段：biz_tag，max_id，step</span><br><span class="line">biz_tag用来区分业务，max_id表示该biz_tag目前所被分配的ID号段的最大值，step表示每次分配的号段长度，原来每次获取ID都要访问数据库，现在只需要把Step设置的足够合理如1000，那么现在可以在1000个ID用完之后再去访问数据库</span><br><span class="line">优点：</span><br><span class="line">	扩张灵活，性能强能够撑起大部分业务场景。</span><br><span class="line">	ID号码是趋势递增的，满足数据库存储和查询性能要求。</span><br><span class="line">	可用性高，即使ID生成服务器不可用，也能够使得业务在短时间内可用，为排查问题争取时间。</span><br><span class="line">缺点：</span><br><span class="line">	可能存在多个节点同时请求ID区间的情况，依赖DB</span><br><span class="line">	</span><br><span class="line">双buffer：将获取一个号段的方式优化成获取两个号段，在一个号段用完之后不用立马去更新号段，还有一个缓存号段备用，这样能够有效解决这种冲突问题，而且采用双buffer的方式，在当前号段消耗了10%的时候就去检查下一个号段有没有准备好，如果没有准备好就去更新下一个号段，当当前号段用完了就切换到下一个已经缓存好的号段去使用，同时在下一个号段消耗到10%的时候，又去检测下一个号段有没有准备好，如此往复。</span><br><span class="line">优点：</span><br><span class="line">	基于JVM存储双buffer的号段，减少了数据库查询，减少了网络依赖，效率更高。</span><br><span class="line">缺点：</span><br><span class="line">	segment号段长度是固定的，业务量大时可能会频繁更新号段，因为原本分配的号段会一下用完</span><br><span class="line">	如果号段长度设置的过长，但凡缓存中有号段没有消耗完，其他节点重新获取的号段与之前相比可能跨度会很大。动态调整Step</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>基于redis、mongodb、zk等中间件生成</p>
</li>
<li><p>雪花算法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">生成一个64bit的整型数字</span><br><span class="line">第一位符号位固定为0，41位时间戳，10位workId，12位序列号</span><br><span class="line">位数可以有不同实现</span><br><span class="line">优点：</span><br><span class="line">	每个毫秒值包含的ID值很多，不够可以变动位数来增加，性能佳（依赖workId的实现）。</span><br><span class="line">	时间戳值在高位，中间是固定的机器码，自增的序列在低位，整个ID是趋势递增的。</span><br><span class="line">	能够根据业务场景数据库节点布置灵活挑战bit位划分，灵活度高。</span><br><span class="line">缺点：</span><br><span class="line">	强依赖于机器时钟，如果时钟回拨，会导致重的ID生成，所以一般基于此的算法发现时钟回拨，都会抛异常处理，阻止ID生成，这可能导致服务不可用。</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="6、分布式锁解决方案"><a href="#6、分布式锁解决方案" class="headerlink" title="6、分布式锁解决方案"></a>6、分布式锁解决方案</h2><p>1、基于Zookeeper的实现方式</p>
<p>2、基于Redis缓存的实现方式</p>
<p>3、基于数据库（唯一索引）的实现方式</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33594592/article/details/133932876">分布式锁解决方案总结_hazelcast 分布式锁-CSDN博客</a> </p>
<h2 id="7、分布式事务解决方案"><a href="#7、分布式事务解决方案" class="headerlink" title="7、分布式事务解决方案"></a>7、分布式事务解决方案</h2><p>XA规范：分布式事务规范，定义了分布式事务模型 </p>
<p>四个角色：事务管理器(协调者TM)、资源管理器(参与者RM)，应用程序AP，通信资源管理器CRM</p>
<p>全局事务：一个横跨多个数据库的事务，要么全部提交、要么全部回滚 </p>
<p>JTA事务时java对XA规范的实现，对应JDBC的单库事务</p>
<p>两阶段协议：</p>
<p><img src="/../img/1716738442669.png" alt="1716738442669"></p>
<p>第一阶段（ prepare ） ：每个参与者执行本地事务但不提交，进入 ready 状态，并通知协调者已经准备就绪。 </p>
<p>第二阶段（ commit ）：当协调者确认每个参与者都 ready 后，通知参与者进行 commit 操作；如果有参与者 fail ，则发送 rollback 命令，各参与者做回滚。</p>
<p>问题：</p>
<ul>
<li>单点故障：一旦事务管理器出现故障，整个系统不可用（参与者都会阻塞住）</li>
<li>数据不一致：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</li>
<li>响应时间较长：参与者和协调者资源都被锁住，提交或者回滚之后才能释放</li>
<li>不确定性：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。</li>
</ul>
<p>三阶段协议：主要是针对两阶段的优化，解决了2PC单点故障的问题，但是性能问题和不一致问题仍然没有根本解决</p>
<p><img src="/../img/1716739059302.png" alt="1716739059302"></p>
<p>引入了超时机制解决参与者阻塞的问题，超时后本地提交，2pc只有协调者有超时机制</p>
<ul>
<li>第一阶段：CanCommit阶段，协调者询问事务参与者，是否有能力完成此次事务。 <ul>
<li>如果都返回yes，则进入第二阶段 </li>
<li>有一个返回no或等待响应超时，则中断事务，并向所有参与者发送abort请求</li>
</ul>
</li>
<li>第二阶段：PreCommit阶段，此时协调者会向所有的参与者发送PreCommit请求，参与者收到后开始执行事务操作。参与者执行完事务操作后（此时属于未提交事务的状态），就会向协调者反馈 “Ack”表示我已经准备好提交了，并等待协调者的下一步指令。</li>
<li>第三阶段：DoCommit阶段， 在阶段二中如果所有的参与者节点都返回了Ack，那么协调者就会从 “预提交状态”转变为“提交状态”。然后向所有的参与者节点发送”doCommit”请求，参与者节点在收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈“Ack”消息，协调者收到所有参与者的Ack消息后完成事务。 相反，如果有一个参与者节点未完成PreCommit的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送abort请求，从而中断事务。</li>
</ul>
<p>TCC（补偿事务）：Try、Confirm、Cancel </p>
<p>针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作 </p>
<p>Try操作做业务检查及资源预留，Confirm做业务确认操作，Cancel实现一个与Try相反的操作既回滚操作。TM首先发起所有的分支事务的try操作，任何一个分支事务的try操作执行失败，TM将会发起所有分支事务的Cancel操作，若try操作全部成功，TM将会发起所有分支事务的Confirm操作，其中 Confirm/Cancel操作若执行失败，TM会进行重试。</p>
<p>TCC模型对业务的侵入性较强，改造的难度较大，每个操作都需要有 try 、 confirm 、 cancel 三个接口实现</p>
<p><code>confirm</code>和<code>cancel</code>接口还必须实现幂等性。 </p>
<p>消息队列的事务消息： </p>
<ul>
<li>发送prepare消息到消息中间件</li>
<li>发送成功后，执行本地事务<ul>
<li>如果事务执行成功，则commit，消息中间件将消息下发至消费端（commit前，消息不会被消费）</li>
<li>如果事务执行失败，则回滚，消息中间件将这条prepare消息删除</li>
</ul>
</li>
<li>消费端接收到消息进行消费，如果消费失败，则不断重试</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Radish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/05/14/Java%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">http://example.com/2024/05/14/Java%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">萝卜的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Tomcat/">Tomcat</a></div><div class="post_share"><div class="social-share" data-image="/../img/jvm.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/14/Tomcat(%E4%B8%80)-Tomcat%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E8%AE%BE%E8%AE%A1%E7%B2%BE%E9%AB%93%E5%88%86%E6%9E%90/" title="Tomcat(一)——Tomcat整体架构及其设计精髓分析"><img class="cover" src="/../img/jvm.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Tomcat(一)——Tomcat整体架构及其设计精髓分析</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E5%85%AB)%E2%80%94%E2%80%94%E8%AE%A9Java%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E7%9A%84JIT%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/" title="深入理解JVM(八)——让Java性能提升的JIT深度剖析"><img class="cover" src="/../img/jvm.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深入理解JVM(八)——让Java性能提升的JIT深度剖析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/14/Tomcat(%E4%B8%80)-Tomcat%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E8%AE%BE%E8%AE%A1%E7%B2%BE%E9%AB%93%E5%88%86%E6%9E%90/" title="Tomcat(一)——Tomcat整体架构及其设计精髓分析"><img class="cover" src="/../img/jvm.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-14</div><div class="title">Tomcat(一)——Tomcat整体架构及其设计精髓分析</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">Radish</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">愿内心深处的懦弱 不再将我吞噬</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">一、Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">1、面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">面向对象的三种特征</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81JDK%E3%80%81JRM%E3%80%81JVM"><span class="toc-number">1.2.</span> <span class="toc-text">2、JDK、JRM、JVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81-x3D-x3D-%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">3、==和equals的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81hashCode%E5%92%8Cequals"><span class="toc-number">1.4.</span> <span class="toc-text">4、hashCode和equals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81final"><span class="toc-number">1.5.</span> <span class="toc-text">5、final</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81String%E3%80%81StringBuffer%E3%80%81StringBuilder"><span class="toc-number">1.6.</span> <span class="toc-text">6、String、StringBuffer、StringBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.</span> <span class="toc-text">7、重载和重写的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.</span> <span class="toc-text">8、接口和抽象类的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81List%E5%92%8CSet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.</span> <span class="toc-text">9、List和Set的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB"><span class="toc-number">1.10.</span> <span class="toc-text">10、ArrayList和LinkedList区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81HashMap%E5%92%8CHashTable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%85%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">11、HashMap和HashTable有什么区别？其底层实现是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81ConcurrentHashMap%E5%8E%9F%E7%90%86%EF%BC%8Cjdk7%E5%92%8Cjdk8%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.12.</span> <span class="toc-text">12、ConcurrentHashMap原理，jdk7和jdk8版本的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK7"><span class="toc-number">1.12.1.</span> <span class="toc-text">JDK7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK8"><span class="toc-number">1.12.2.</span> <span class="toc-text">JDK8</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">13、什么是字节码？采用字节码的好处是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-number">1.14.</span> <span class="toc-text">14、Java中的异常体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.15.</span> <span class="toc-text">15、Java类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.16.</span> <span class="toc-text">16、双亲委托模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81GC%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6"><span class="toc-number">1.17.</span> <span class="toc-text">17、GC如何判断对象可以被回收</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3"><span class="toc-number">2.</span> <span class="toc-text">二、线程、并发相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.</span> <span class="toc-text">1、线程的生命周期？线程有几种状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81sleep-%E3%80%81wait-%E3%80%81join-%E3%80%81yield-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">2、sleep()、wait()、join()、yield()的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.3.</span> <span class="toc-text">3、对线程安全的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Thread%E3%80%81Runable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">4、Thread、Runable的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%AF%B9%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.5.</span> <span class="toc-text">5、对守护线程的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.6.</span> <span class="toc-text">6、ThreadLocal的原理和使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%8E%9F%E5%9B%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="toc-number">2.7.</span> <span class="toc-text">7、ThreadLocal内存泄露原因，如何避免</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%B9%B6%E5%8F%91%E3%80%81%E5%B9%B6%E8%A1%8C%E3%80%81%E4%B8%B2%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.8.</span> <span class="toc-text">8、并发、并行、串行的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%B9%B6%E5%8F%91%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">2.9.</span> <span class="toc-text">9、并发的三大特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81volatile"><span class="toc-number">2.10.</span> <span class="toc-text">10、volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E8%A7%A3%E9%87%8A%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">11、为什么使用线程池？解释下线程池的参数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E7%AE%80%E8%BF%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">2.12.</span> <span class="toc-text">12、简述线程池处理流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%88%E6%B7%BB%E5%8A%A0%E5%88%97%E9%98%9F%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%88%E5%88%9B%E5%BB%BA%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">13、线程池中阻塞队列的作用？为什么是先添加列队而不是先创建最大线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-number">2.14.</span> <span class="toc-text">14、线程池中线程复用原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Spring"><span class="toc-number">3.</span> <span class="toc-text">三、Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAIOC%E5%AE%B9%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">1、如何实现一个IOC容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Spring%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2、Spring是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9AOP%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.3.</span> <span class="toc-text">3、谈谈你对AOP的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9IOC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.4.</span> <span class="toc-text">4、谈谈你对IOC的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81BeanFactory%E5%92%8CApplicationContext%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">5、BeanFactory和ApplicationContext有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BSpring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">6、描述一下Spring Bean的生命周期？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E8%A7%A3%E9%87%8A%E4%B8%8BSpring%E6%94%AF%E6%8C%81%E7%9A%84%E5%87%A0%E7%A7%8Dbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">7、解释下Spring支持的几种bean的作用域？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8BBean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B9%88%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">8、Spring框架中的单例Bean是线程安全的么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">9、Spring框架中都用到了哪些设计模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9F"><span class="toc-number">3.10.</span> <span class="toc-text">10、Spring事务的实现方式和原理以及隔离级别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">3.11.</span> <span class="toc-text">11、Spring事务传播机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81Spring%E4%BA%8B%E5%8A%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88"><span class="toc-number">3.12.</span> <span class="toc-text">12、Spring事务什么时候会失效?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFbean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.13.</span> <span class="toc-text">13、什么是bean的自动装配，有哪些方式？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81springmvc%E3%80%81springBoot"><span class="toc-number">4.</span> <span class="toc-text">四、springmvc、springBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Spring-Boot%E3%80%81Spring-MVC-%E5%92%8C-Spring-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">1、Spring Boot、Spring MVC 和 Spring 有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81SpringMVC-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">2、SpringMVC 工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Spring-MVC%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">3、Spring MVC的主要组件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Spring-Boot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">4、Spring Boot 自动配置原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Spring-Boot-%E4%B8%AD%E7%9A%84-Starter"><span class="toc-number">4.5.</span> <span class="toc-text">5、如何理解 Spring Boot 中的 Starter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">4.6.</span> <span class="toc-text">6、什么是嵌入式服务器？为什么要使用嵌入式服务器?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Mybatis"><span class="toc-number">5.</span> <span class="toc-text">五、Mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81mybatis%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.1.</span> <span class="toc-text">1、mybatis优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81MyBatis%E4%B8%8EHibernate%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">2、MyBatis与Hibernate有哪些不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">3、#{}和${}的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%AE%80%E8%BF%B0-Mybatis-%E7%9A%84%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">4、简述 Mybatis 的插件运行原理，如何编写一个插件？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81MySQL"><span class="toc-number">6.</span> <span class="toc-text">六、MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">1、索引的基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Mysql%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.2.</span> <span class="toc-text">2、Mysql聚簇和非聚簇索引的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Mysql%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%90%84%E8%87%AA%E4%BC%98%E5%8A%BF"><span class="toc-number">6.3.</span> <span class="toc-text">3、Mysql索引的数据结构，各自优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">4、索引设计的原则？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">6.5.</span> <span class="toc-text">5、什么是最左前缀原则？什么是最左匹配原则？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">6.6.</span> <span class="toc-text">6、锁的类型有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%94%81%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">6.7.</span> <span class="toc-text">7、InnoDB存储引擎的锁的算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%85%B3%E5%BF%83%E8%BF%87%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E9%87%8C%E9%9D%A2%E7%9A%84sql%E8%80%97%E6%97%B6%E5%90%97%EF%BC%9F%E7%BB%9F%E8%AE%A1%E8%BF%87%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F%E5%AF%B9%E6%85%A2%E6%9F%A5%E8%AF%A2%E9%83%BD%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E8%BF%87%EF%BC%9F"><span class="toc-number">6.8.</span> <span class="toc-text">8、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">6.9.</span> <span class="toc-text">9、事务的基本特性和隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81ACID%E9%9D%A0%E4%BB%80%E4%B9%88%E4%BF%9D%E8%AF%81%E7%9A%84%EF%BC%9F"><span class="toc-number">6.10.</span> <span class="toc-text">10、ACID靠什么保证的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81MVCC"><span class="toc-number">6.11.</span> <span class="toc-text">11、MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undo%E6%97%A5%E5%BF%97%E7%89%88%E6%9C%AC%E9%93%BE%E4%B8%8Eread-view%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.11.1.</span> <span class="toc-text">undo日志版本链与read view机制详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E5%88%86%E8%A1%A8%E5%90%8E%E9%9D%9Esharding-key%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%8C%E5%88%86%E8%A1%A8%E5%90%8E%E7%9A%84%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-number">6.12.</span> <span class="toc-text">12、分表后非sharding_key的查询怎么处理，分表后的排序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81MySQL%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">6.13.</span> <span class="toc-text">13、MySQL主从同步原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E7%AE%80%E8%BF%B0MyISAM%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.14.</span> <span class="toc-text">14、简述MyISAM和InnoDB的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM"><span class="toc-number">6.14.1.</span> <span class="toc-text">MyISAM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDb"><span class="toc-number">6.14.2.</span> <span class="toc-text">InnoDb</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E7%AE%80%E8%BF%B0mysql%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">6.15.</span> <span class="toc-text">15、简述mysql中索引类型及对数据库的性能的影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81mysql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E6%80%8E%E4%B9%88%E7%9C%8B"><span class="toc-number">6.16.</span> <span class="toc-text">16、mysql执行计划怎么看</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81Redis"><span class="toc-number">7.</span> <span class="toc-text">七、Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81RDB%E5%92%8CAOF%E6%9C%BA%E5%88%B6"><span class="toc-number">7.1.</span> <span class="toc-text">1、RDB和AOF机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Redis%E7%9A%84%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">7.2.</span> <span class="toc-text">2、Redis的过期键的删除策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E3%80%81%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">7.3.</span> <span class="toc-text">3、Redis线程模型、单线程快的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%AE%80%E8%BF%B0Redis%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.4.</span> <span class="toc-text">4、简述Redis事务实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BA%8B%E5%8A%A1%E5%BC%80%E5%A7%8B"><span class="toc-number">7.4.1.</span> <span class="toc-text">1、事务开始</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%91%BD%E4%BB%A4%E5%85%A5%E9%98%9F"><span class="toc-number">7.4.2.</span> <span class="toc-text">2、命令入队</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="toc-number">7.4.3.</span> <span class="toc-text">3、事务执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Redis%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88"><span class="toc-number">7.5.</span> <span class="toc-text">5、Redis集群方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">7.6.</span> <span class="toc-text">6、redis 主从复制的核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6"><span class="toc-number">7.6.1.</span> <span class="toc-text">全量复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E5%A4%8D%E5%88%B6"><span class="toc-number">7.6.2.</span> <span class="toc-text">部分复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">7.7.</span> <span class="toc-text">7、缓存雪崩、缓存穿透、缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">7.7.1.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">7.7.2.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">7.7.3.</span> <span class="toc-text">缓存击穿</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F-x2F-%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">8.</span> <span class="toc-text">八、分布式/微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81CAP%E7%90%86%E8%AE%BA%EF%BC%8CBASE%E7%90%86%E8%AE%BA"><span class="toc-number">8.1.</span> <span class="toc-text">1、CAP理论，BASE理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E3%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.2.</span> <span class="toc-text">2、负载均衡算法、类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95"><span class="toc-number">8.2.1.</span> <span class="toc-text">负载均衡算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.2.2.</span> <span class="toc-text">类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B8%8B%EF%BC%8CSession%E5%85%B1%E4%BA%AB%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%A1%88"><span class="toc-number">8.3.</span> <span class="toc-text">3、分布式架构下，Session共享有什么方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%AE%80%E8%BF%B0%E4%BD%A0%E5%AF%B9RPC%E3%80%81RMI%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">8.4.</span> <span class="toc-text">4、简述你对RPC、RMI的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88"><span class="toc-number">8.5.</span> <span class="toc-text">5、分布式id生成方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">8.6.</span> <span class="toc-text">6、分布式锁解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">8.7.</span> <span class="toc-text">7、分布式事务解决方案</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/06/26/ES(%E4%B8%89)-ElasticSearch%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%85%A5%E4%B8%8E%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2%E5%AE%9E%E6%88%98/" title="ES(三)-ElasticSearch搜索技术深入与聚合查询实战"><img src="/../img/es_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ES(三)-ElasticSearch搜索技术深入与聚合查询实战"></a><div class="content"><a class="title" href="/2024/06/26/ES(%E4%B8%89)-ElasticSearch%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%85%A5%E4%B8%8E%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2%E5%AE%9E%E6%88%98/" title="ES(三)-ElasticSearch搜索技术深入与聚合查询实战">ES(三)-ElasticSearch搜索技术深入与聚合查询实战</a><time datetime="2024-06-26T12:23:00.000Z" title="发表于 2024-06-26 20:23:00">2024-06-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/21/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8(%E4%B8%80)-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/" title="PyTorch深度学习快速入门(一)-环境安装"><img src="/../img/pytorch.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PyTorch深度学习快速入门(一)-环境安装"></a><div class="content"><a class="title" href="/2024/06/21/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8(%E4%B8%80)-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/" title="PyTorch深度学习快速入门(一)-环境安装">PyTorch深度学习快速入门(一)-环境安装</a><time datetime="2024-06-21T15:37:00.000Z" title="发表于 2024-06-21 23:37:00">2024-06-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/18/ES(%E4%BA%8C)-ElasticSearch%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95Query%20DSL%E5%AE%9E%E6%88%98/" title="ES(二)-ElasticSearch高级语法Query DSL实战"><img src="/../img/es_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ES(二)-ElasticSearch高级语法Query DSL实战"></a><div class="content"><a class="title" href="/2024/06/18/ES(%E4%BA%8C)-ElasticSearch%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95Query%20DSL%E5%AE%9E%E6%88%98/" title="ES(二)-ElasticSearch高级语法Query DSL实战">ES(二)-ElasticSearch高级语法Query DSL实战</a><time datetime="2024-06-18T15:50:00.000Z" title="发表于 2024-06-18 23:50:00">2024-06-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/11/ES(%E4%B8%80)-ElasticSearch%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/" title="ES(一)-ElasticSearch快速入门实战"><img src="/../img/es_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ES(一)-ElasticSearch快速入门实战"></a><div class="content"><a class="title" href="/2024/06/11/ES(%E4%B8%80)-ElasticSearch%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/" title="ES(一)-ElasticSearch快速入门实战">ES(一)-ElasticSearch快速入门实战</a><time datetime="2024-06-11T15:06:00.000Z" title="发表于 2024-06-11 23:06:00">2024-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/08/Git(%E4%BA%8C)-%E6%90%AD%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%A7%81%E6%9C%89Git%E6%9C%8D%E5%8A%A1/" title="Git(二)-搭建企业私有Git服务"><img src="/../img/git.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git(二)-搭建企业私有Git服务"></a><div class="content"><a class="title" href="/2024/06/08/Git(%E4%BA%8C)-%E6%90%AD%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%A7%81%E6%9C%89Git%E6%9C%8D%E5%8A%A1/" title="Git(二)-搭建企业私有Git服务">Git(二)-搭建企业私有Git服务</a><time datetime="2024-06-08T04:38:00.000Z" title="发表于 2024-06-08 12:38:00">2024-06-08</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2023 - 2024 By Radish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>