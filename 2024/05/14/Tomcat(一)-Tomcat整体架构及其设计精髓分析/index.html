<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Tomcat(一)——Tomcat整体架构及其设计精髓分析 | 萝卜的博客</title><meta name="author" content="Radish"><meta name="copyright" content="Radish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Tomcat介绍1、Tomcat介绍Tomcat是Apache Software Foundation（Apache软件基金会）开发的一款开源的Java Servlet容器。它是一种Web服务器，用于在服务器端运行Java Servlet和JavaServer Pages (JSP)技术。它可以为Java Web应用程序提供运行环境，并通过HTTP协议处理客户端请求。Tomcat也支持多种We">
<meta property="og:type" content="article">
<meta property="og:title" content="Tomcat(一)——Tomcat整体架构及其设计精髓分析">
<meta property="og:url" content="http://example.com/2024/05/14/Tomcat(%E4%B8%80)-Tomcat%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E8%AE%BE%E8%AE%A1%E7%B2%BE%E9%AB%93%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="萝卜的博客">
<meta property="og:description" content="一、Tomcat介绍1、Tomcat介绍Tomcat是Apache Software Foundation（Apache软件基金会）开发的一款开源的Java Servlet容器。它是一种Web服务器，用于在服务器端运行Java Servlet和JavaServer Pages (JSP)技术。它可以为Java Web应用程序提供运行环境，并通过HTTP协议处理客户端请求。Tomcat也支持多种We">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/jvm.jpg">
<meta property="article:published_time" content="2024-05-14T13:06:00.000Z">
<meta property="article:modified_time" content="2024-05-14T13:54:26.788Z">
<meta property="article:author" content="Radish">
<meta property="article:tag" content="Tomcat">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/jvm.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/05/14/Tomcat(%E4%B8%80)-Tomcat%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E8%AE%BE%E8%AE%A1%E7%B2%BE%E9%AB%93%E5%88%86%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Tomcat(一)——Tomcat整体架构及其设计精髓分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-14 21:54:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li><li><a class="site-page child" href="/%E8%A7%86%E9%A2%91"><i class="fa-fw /movies/"></i><span> 1</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="萝卜的博客"><span class="site-name">萝卜的博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li><li><a class="site-page child" href="/%E8%A7%86%E9%A2%91"><i class="fa-fw /movies/"></i><span> 1</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Tomcat(一)——Tomcat整体架构及其设计精髓分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-14T13:06:00.000Z" title="发表于 2024-05-14 21:06:00">2024-05-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-14T13:54:26.788Z" title="更新于 2024-05-14 21:54:26">2024-05-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%90%8E%E7%AB%AF/">Java后端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%90%8E%E7%AB%AF/Tomcat/">Tomcat</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Tomcat(一)——Tomcat整体架构及其设计精髓分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="一、Tomcat介绍"><a href="#一、Tomcat介绍" class="headerlink" title="一、Tomcat介绍"></a>一、Tomcat介绍</h1><h2 id="1、Tomcat介绍"><a href="#1、Tomcat介绍" class="headerlink" title="1、Tomcat介绍"></a>1、Tomcat介绍</h2><p>Tomcat是Apache Software Foundation（Apache软件基金会）开发的一款开源的Java Servlet容器。它是一种Web服务器，用于在服务器端运行Java Servlet和JavaServer Pages (JSP)技术。它可以为Java Web应用程序提供运行环境，并通过HTTP协议处理客户端请求。Tomcat也支持多种Web应用程序开发技术，例如JavaServer Faces (JSF)、Java Persistence API (JPA)等。总的来说，Tomcat是一款高效、稳定和易于使用的Web服务器。</p>
<p>Tomcat核心： Http服务器+Servlet容器</p>
<p><img src="/../img/1715693535200.png" alt="1715693535200"></p>
<h2 id="2、Tomcat目录结构"><a href="#2、Tomcat目录结构" class="headerlink" title="2、Tomcat目录结构"></a>2、Tomcat目录结构</h2><p>Tomcat的解压之后的目录可以看到如下的目录结构</p>
<p><img src="/../img/1715693552255.png" alt="1715693552255"></p>
<ul>
<li>bin</li>
</ul>
<p>bin目录主要是用来存放tomcat的脚本，如startup.sh , shutdown.sh</p>
<ul>
<li><p>conf</p>
</li>
<li><ul>
<li>catalina.policy: Tomcat安全策略文件,控制JVM相关权限,具体可以参考java. security.Permission</li>
<li>catalina.properties : Tomcat Catalina行为控制配置文件,比如Common ClassLoader</li>
<li>logging.properties  : Tomcat日志配置文件, JDK Logging</li>
<li>server.xml : Tomcat Server配置文件</li>
<li>GlobalNamingResources :全局JNDI资源</li>
<li>context.xml :全局Context配置文件</li>
<li>tomcat-users.xml : Tomcat角色配置文件</li>
<li>web.xml : Servlet标准的web.xml部署文件, Tomcat默认实现部分配置入内:</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>org.apache.catalina.servlets.DefaultServlet</li>
<li>org.apache.jasper.servlet.JspServlet</li>
</ul>
</li>
</ul>
</li>
<li><p>lib</p>
</li>
</ul>
<p>公共类库</p>
<ul>
<li>logs</li>
</ul>
<p>tomcat在运行过程中产生的日志文件</p>
<ul>
<li>webapps</li>
</ul>
<p>用来存放应用程序，当tomcat启动时会去加载webapps目录下的应用程序</p>
<ul>
<li>work</li>
</ul>
<p>用来存放tomcat在运行时的编译后文件，例如JSP编译后的文件</p>
<h2 id="3、web应用部署的三种方式"><a href="#3、web应用部署的三种方式" class="headerlink" title="3、web应用部署的三种方式"></a>3、web应用部署的三种方式</h2><ul>
<li>拷贝到webapps目录下</li>
</ul>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//指定appBase     </span><br><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>server.xml的Context标签下配置Context</li>
</ul>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"D:\mvc"</span> <span class="attr">path</span>=<span class="string">"/mvc"</span>  <span class="attr">reloadable</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>path:指定访问该Web应用的URL入口（context-path）</p>
<p>docBase:指定Web应用的文件路径，可以给定绝对路径，也可以给定相对于的appBase属性的相对路径。</p>
<p>reloadable:如果这个属性设为true，tomcat服务器在运行状态下会监视在WEB-INF/classes和WEB-INF/lib目录下class文件的改动，如果监测到有class文件被更新的，服务器会自动重新加载Web应用。</p>
</blockquote>
<ul>
<li>在$CATALINA_BASE/conf/[enginename]/[hostname]/ 目录下（默认conf/Catalina/localhost）创建xml文件，文件名就是contextPath。</li>
</ul>
<p>比如创建mvc.xml，path就是/mvc </p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"D:\mvc"</span>  <span class="attr">reloadable</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意：想要根路径访问，文件名为ROOT.xml</p>
<h1 id="二、Tomcat整体架构分析"><a href="#二、Tomcat整体架构分析" class="headerlink" title="二、Tomcat整体架构分析"></a>二、Tomcat整体架构分析</h1><p>Tomcat 要实现 2 个核心功能：</p>
<ul>
<li>处理 Socket 连接，负责网络字节流与 Request 和 Response 对象的转化。</li>
<li>加载和管理 Servlet，以及具体处理 Request 请求。</li>
</ul>
<p>因此 Tomcat 设计了两个核心组件<strong>连接器（Connector）</strong>和<strong>容器（Container）</strong>来分别做这两件事情。连接器负责对外交流，容器负责内部处理。</p>
<h2 id="1、Tomcat架构图"><a href="#1、Tomcat架构图" class="headerlink" title="1、Tomcat架构图"></a>1、Tomcat架构图</h2><p>Tomcat的架构分为以下几个部分：</p>
<ol>
<li>Connector：Tomcat的连接器，用于接收请求并将其发送给容器。</li>
<li>Container：Tomcat的容器，负责管理Servlet、JSP和静态资源的生命周期。</li>
<li>Engine：Tomcat的引擎，管理容器的生命周期和分配请求。</li>
<li>Host：Tomcat的主机，可以管理多个Web应用程序。</li>
<li>Context：Tomcat的上下文，用于管理单个Web应用程序的配置信息。</li>
<li>Servlet：Tomcat的Servlet，负责处理请求并生成响应。</li>
<li>JSP：Tomcat的JSP，用于动态生成Web内容。</li>
</ol>
<p>总的来说，Tomcat的架构是一个分层的架构，每一层都有其自己的功能和职责。该架构可以提高Tomcat的性能和可维护性，并使得Tomcat可以支持大量的Java Web应用程序。</p>
<p><img src="/../img/1715694092853.png" alt="1715694092853"></p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/mvc2/">http://localhost:8080/mvc2/</a></p>
<h2 id="2、Tomcat核心组件详解"><a href="#2、Tomcat核心组件详解" class="headerlink" title="2、Tomcat核心组件详解"></a>2、<strong>Tomcat核心组件详解</strong></h2><h3 id="Server-组件"><a href="#Server-组件" class="headerlink" title="Server 组件"></a><strong>Server 组件</strong></h3><p>指的就是整个 Tomcat 服务器，包含多组服务（Service），负责管理和启动各个Service，同时监听 8005 端口发过来的 shutdown 命令，用于关闭整个容器 。</p>
<h3 id="Service组件"><a href="#Service组件" class="headerlink" title="Service组件"></a><strong>Service组件</strong></h3><p>每个 Service 组件都包含了若干用于接收客户端消息的 Connector 组件和处理请求的 Engine 组件。 Service 组件还包含了若干 Executor 组件，每个 Executor 都是一个线程池，它可以为 Service 内所有组件提供线程池执行任务。Tomcat 内可能有多个 Service，这样的设计也是出于灵活性的考虑。通过在 Tomcat 中配置多个 Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。</p>
<p><img src="/../img/1715694206028.png" alt="1715694206028"></p>
<h3 id="连接器Connector组件"><a href="#连接器Connector组件" class="headerlink" title="连接器Connector组件"></a><strong>连接器Connector组件</strong></h3><p>Tomcat 与外部世界的连接器，监听固定端口接收外部请求，传递给 Container，并将Container 处理的结果返回给外部。连接器对 Servlet 容器屏蔽了不同的应用层协议及 I/O 模型，无论是 HTTP 还是 AJP，在容器中获取到的都是一个标准的 ServletRequest 对象。</p>
<h3 id="容器Container组件"><a href="#容器Container组件" class="headerlink" title="容器Container组件"></a><strong>容器Container组件</strong></h3><p>容器，顾名思义就是用来装载东西的器具，在 Tomcat 里，容器就是用来装载 Servlet 的。Tomcat 通过一种分层的架构，使得 Servlet 容器具有很好的灵活性。Tomcat 设计了 4 种容器，分别是 Engine、Host、Context 和 Wrapper。这 4 种容器不是平行关系，而是父子关系。</p>
<ul>
<li>Engine：引擎，Servlet 的顶层容器，用来管理多个虚拟站点，一个 Service 最多只能有一个 Engine；</li>
<li>Host：虚拟主机，负责 web 应用的部署和 Context 的创建。可以给 Tomcat 配置多个虚拟主机地址，而一个虚拟主机下可以部署多个 Web 应用程序；</li>
<li>Context：Web 应用上下文，包含多个 Wrapper，负责 web 配置的解析、管理所有的 Web 资源。一个Context对应一个 Web 应用程序。</li>
<li>Wrapper：表示一个 Servlet，最底层的容器，是对 Servlet 的封装，负责 Servlet 实例的创建、执行和销毁。</li>
</ul>
<p><img src="/../img/1715694274797.png" alt="1715694274797"></p>
<h2 id="3、结合Server-xml理解Tomcat架构"><a href="#3、结合Server-xml理解Tomcat架构" class="headerlink" title="3、结合Server.xml理解Tomcat架构"></a>3、<strong>结合Server.xml理解Tomcat架构</strong></h2><p>我们可以通过 Tomcat 的 server.xml 配置文件来加深对 Tomcat 架构的理解。Tomcat 采用了组件化的设计，它的构成组件都是可配置的，其中最外层的是 Server，其他组件按照一定的格式要求配置在这个顶层容器中。 </p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span>&gt;</span>    //顶层组件，可以包括多个Service</span><br><span class="line">    <span class="tag">&lt;<span class="name">Service</span>&gt;</span>  //顶层组件，可包含一个Engine，多个连接器</span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span>/&gt;</span>//连接器组件，代表通信接口           </span><br><span class="line">        <span class="tag">&lt;<span class="name">Engine</span>&gt;</span>//容器组件，一个Engine组件处理Service中的所有请求，包含多个Host</span><br><span class="line">            <span class="tag">&lt;<span class="name">Host</span>&gt;</span>  //容器组件，处理特定的Host下客户请求，可包含多个Context</span><br><span class="line">                <span class="tag">&lt;<span class="name">Context</span>/&gt;</span>  //容器组件，为特定的Web应用处理所有的客户请求</span><br><span class="line">        <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Service</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span>    </span><br></pre></td></tr></tbody></table></figure>

<p>Tomcat启动期间会通过解析 server.xml，利用反射创建相应的组件，所以xml中的标签和源码一一对应。</p>
<p>思考：Tomcat 是怎么确定请求是由哪个 Wrapper 容器里的 Servlet 来处理的呢？</p>
<h2 id="4、请求定位-Servlet-的过程"><a href="#4、请求定位-Servlet-的过程" class="headerlink" title="4、请求定位 Servlet 的过程"></a>4、<strong>请求定位 Servlet 的过程</strong></h2><p>Tomcat 是用 Mapper 组件来完成这个任务的。Mapper 组件的功能就是将用户请求的 URL 定位到一个 Servlet，它的工作原理是：Mapper 组件里保存了 Web 应用的配置信息，其实就是容器组件与访问路径的映射关系，比如 Host 容器里配置的域名、Context 容器里的 Web 应用路径，以及 Wrapper 容器里 Servlet 映射的路径，你可以想象这些配置信息就是一个多层次的 Map。当一个请求到来时，Mapper 组件通过解析请求 URL 里的域名和路径，再到自己保存的 Map 里去查找，就能定位到一个 Servlet。一个请求 URL 最后只会定位到一个 Wrapper 容器，也就是一个 Servlet。</p>
<p><img src="/../img/1715694319719.png" alt="1715694319719"></p>
<h1 id="三、Tomcat架构设计精髓分析"><a href="#三、Tomcat架构设计精髓分析" class="headerlink" title="三、Tomcat架构设计精髓分析"></a>三、<strong>Tomcat架构设计精髓分析</strong></h1><h2 id="1、Connector高内聚低耦合设计"><a href="#1、Connector高内聚低耦合设计" class="headerlink" title="1、Connector高内聚低耦合设计"></a>1、<strong>Connector高内聚低耦合设计</strong></h2><p>优秀的模块化设计应该考虑高内聚、低耦合：</p>
<ul>
<li>高内聚是指相关度比较高的功能要尽可能集中，不要分散。</li>
<li>低耦合是指两个相关的模块要尽可能减少依赖的部分和降低依赖的程度，不要让两个模块产生强依赖。</li>
</ul>
<p>Tomcat连接器需要实现的功能：</p>
<ul>
<li>监听网络端口。</li>
<li>接受网络连接请求。</li>
<li>读取请求网络字节流。</li>
<li>根据具体应用层协议（HTTP/AJP）解析字节流，生成统一的 Tomcat Request 对象。</li>
<li>将 Tomcat Request 对象转成标准的 ServletRequest。</li>
<li>调用 Servlet 容器，得到 ServletResponse。</li>
<li>将 ServletResponse 转成 Tomcat Response 对象。</li>
<li>将 Tomcat Response 转成网络字节流。</li>
<li>将响应字节流写回给浏览器。</li>
</ul>
<p>分析连接器详细功能列表，我们会发现连接器需要完成 3 个高内聚的功能：</p>
<ul>
<li><strong>网络通信。</strong></li>
<li><strong>应用层协议解析。</strong></li>
<li><strong>Tomcat Request/Response 与 ServletRequest/ServletResponse 的转化。</strong></li>
</ul>
<p>因此 Tomcat 的设计者设计了 3 个组件来实现这 3 个功能，分别是 EndPoint、Processor 和 Adapter。</p>
<ul>
<li><strong>EndPoint 负责提供字节流给 Processor；</strong></li>
<li><strong>Processor 负责提供 Tomcat Request 对象给 Adapter；</strong></li>
<li><strong>Adapter 负责提供 ServletRequest 对象给容器。</strong></li>
</ul>
<blockquote>
<p>组件之间通过抽象接口交互。这样做的好处是封装变化。这是面向对象设计的精髓，将系统中经常变化的部分和稳定的部分隔离，有助于增加复用性，并降低系统耦合度。</p>
</blockquote>
<p>由于 I/O 模型和应用层协议可以自由组合，比如 NIO + HTTP 或者 NIO2 + AJP。Tomcat 的设计者将网络通信和应用层协议解析放在一起考虑，设计了一个叫 <strong>ProtocolHandler 的接口</strong>来封装这两种变化点。各种协议和通信模型的组合有相应的具体实现类。比如：Http11NioProtocol 和 AjpNioProtocol。</p>
<p>除了这些变化点，系统也存在一些相对稳定的部分，因此 <strong>Tomcat 设计了一系列抽象基类来封装这些稳定的部分</strong>，抽象基类 AbstractProtocol 实现了 ProtocolHandler 接口。每一种应用层协议有自己的抽象基类，比如 AbstractAjpProtocol 和 AbstractHttp11Protocol，具体协议的实现类扩展了协议层抽象基类。</p>
<p><img src="/../img/1715694395066.png" alt="1715694395066"></p>
<p><strong>ProtocolHandler</strong> </p>
<p><strong>连接器用 ProtocolHandler 来处理网络连接和应用层协议</strong>，包含了 2 个重要部件：EndPoint 和 Processor。<br><img src="/../img/1715694413104.png" alt="1715694413104"></p>
<p><strong>连接器用 ProtocolHandler 接口来封装通信协议和 I/O 模型的差异，ProtocolHandler 内部又分为 EndPoint 和 Processor 模块，EndPoint 负责底层 Socket 通信，Proccesor 负责应用层协议解析。连接器通过适配器 Adapter 调用容器。</strong></p>
<p><strong>EndPoint</strong></p>
<p><strong>EndPoint 是通信端点</strong>，即通信监听的接口，是具体的 Socket 接收和发送处理器，<strong>是对传输层的抽象</strong>，因此 EndPoint 是用来实现 TCP/IP 协议的。		</p>
<p>EndPoint 是一个接口，对应的抽象实现类是 AbstractEndpoint，而 AbstractEndpoint 的具体子类，比如在 NioEndpoint 和 Nio2Endpoint 中，有两个重要的子组件：<strong>Acceptor 和 SocketProcessor</strong>。其中 Acceptor 用于监听 Socket 连接请求。SocketProcessor 用于处理接收到的 Socket 请求，它实现 Runnable 接口，在 Run 方法里调用协议处理组件 Processor 进行处理。为了提高处理能力，SocketProcessor 被提交到线程池来执行，而这个**线程池叫作执行器（Executor)**。</p>
<p><strong>Processor</strong></p>
<p> Processor 用来实现 HTTP/AJP 协议，Processor 接收来自 EndPoint 的 Socket，读取字节流解析成 Tomcat Request 和 Response 对象，并通过 Adapter 将其提交到容器处理，<strong>Processor 是对应用层协议的抽象</strong>。</p>
<p>Processor 是一个接口，定义了请求的处理等方法。它的抽象实现类 AbstractProcessor 对一些协议共有的属性进行封装，没有对方法进行实现。具体的实现有 AJPProcessor、HTTP11Processor 等，这些具体实现类实现了特定协议的解析方法和请求处理方式。<br><img src="/../img/1715694477700.png" alt="1715694477700"></p>
<p>EndPoint 接收到 Socket 连接后，生成一个 SocketProcessor 任务提交到线程池去处理，SocketProcessor 的 Run 方法会调用 Processor 组件去解析应用层协议，Processor 通过解析生成 Request 对象后，会调用 Adapter 的 Service 方法。</p>
<p><strong>Adapter</strong> </p>
<p>由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat 定义了自己的 Request 类来“存放”这些请求信息。ProtocolHandler 接口负责解析请求并生成 Tomcat Request 类。但是这个 Request 对象不是标准的 ServletRequest，也就意味着，不能用 Tomcat Request 作为参数来调用容器。Tomcat 设计者的解决方案是引入 CoyoteAdapter，这是适配器模式的经典运用，连接器调用 CoyoteAdapter 的 Sevice 方法，传入的是 Tomcat Request 对象，CoyoteAdapter 负责将 Tomcat Request 转成 ServletRequest，再调用容器的 Service 方法。</p>
<p>设计复杂系统的基本思路：</p>
<p>首先要分析需求，根据高内聚低耦合的原则确定子模块，然后找出子模块中的变化点和不变点，用接口和抽象基类去封装不变点，在抽象基类中定义模板方法，让子类自行实现抽象方法，也就是具体子类去实现变化点。</p>
<h2 id="2、父子容器组合模式设计"><a href="#2、父子容器组合模式设计" class="headerlink" title="2、父子容器组合模式设计"></a>2、<strong>父子容器组合模式设计</strong></h2><p>思考：Tomcat 设计了 4 种容器，分别是 Engine、Host、Context 和 Wrapper，Tomcat 是怎么管理这些容器的？</p>
<p>Tomcat 采用组合模式来管理这些容器。具体实现方法是，所有容器组件都实现了 Container 接口，因此组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性。</p>
<p>Container 接口定义如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Container</span> <span class="keyword">extends</span> <span class="title class_">Lifecycle</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="keyword">public</span> Container <span class="title function_">getParent</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(Container container)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(Container child)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeChild</span><span class="params">(Container child)</span>;</span><br><span class="line">    <span class="keyword">public</span> Container <span class="title function_">findChild</span><span class="params">(String name)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="3、Pipeline-Valve-责任链模式设计"><a href="#3、Pipeline-Valve-责任链模式设计" class="headerlink" title="3、Pipeline-Valve 责任链模式设计"></a>3、<strong>Pipeline-Valve 责任链模式设计</strong></h2><p>连接器中的 Adapter 会调用容器的 Service 方法来执行 Servlet，最先拿到请求的是 Engine 容器，Engine 容器对请求做一些处理后，会把请求传给自己子容器 Host 继续处理，依次类推，最后这个请求会传给 Wrapper 容器，Wrapper 会调用最终的 Servlet 来处理。那么这个调用过程具体是怎么实现的呢？答案是<strong>使用 Pipeline-Valve 管道</strong>。</p>
<p><strong>Pipeline-Valve 是责任链模式</strong>，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理。</p>
<p>为什么要使用管道机制？</p>
<p>在一个比较复杂的大型系统中，如果一个对象或数据流需要进行繁杂的逻辑处理，我们可以选择在一个大的组件中直接处理这些繁杂的业务逻辑， 这个方式虽然达到目的，但扩展性和可重用性较差， 因为可能牵一发而动全身。<strong>更好的解决方案是采用管道机制，用一条管道把多个对象(阀门部件)连接起来，整体看起来就像若干个阀门嵌套在管道中一样，而处理逻辑放在阀门上。</strong></p>
<h3 id="Vavle接口设计"><a href="#Vavle接口设计" class="headerlink" title="Vavle接口设计"></a><strong>Vavle接口设计</strong></h3><p>理解它的设计，第一步就是阀门设计。Valve 表示一个处理点，比如权限认证和记录日志。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Valve</span> {</span><br><span class="line">    <span class="keyword">public</span> Valve <span class="title function_">getNext</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Valve valve)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Pipline接口设计"><a href="#Pipline接口设计" class="headerlink" title="Pipline接口设计"></a><strong>Pipline接口设计</strong></h3><p>由于Pipline是为容器设计的，所以它在设计时加入了一个Contained接口, 就是为了制定当前Pipline所属的容器</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pipeline</span> <span class="keyword">extends</span> <span class="title class_">Contained</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基础的处理阀</span></span><br><span class="line">    <span class="keyword">public</span> Valve <span class="title function_">getBasic</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBasic</span><span class="params">(Valve valve)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对节点（阀门）增删查</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addValve</span><span class="params">(Valve valve)</span>;</span><br><span class="line">    <span class="keyword">public</span> Valve[] getValves();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeValve</span><span class="params">(Valve valve)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个节点，遍历的起点，所以需要有这方法</span></span><br><span class="line">    <span class="keyword">public</span> Valve <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否所有节点（阀门）都支持处理Servlet3异步处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAsyncSupported</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到所有不支持Servlet3异步处理的阀门</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findNonAsyncValves</span><span class="params">(Set&lt;String&gt; result)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Pipeline 中维护了 Valve 链表，Valve 可以插入到 Pipeline 中，对请求做某些处理。整个调用链的触发是 Valve 来完成的，Valve 完成自己的处理后，调用 getNext.invoke() 来触发下一个 Valve 调用。<strong>每一个容器都有一个 Pipeline 对象</strong>，只要触发这个 Pipeline 的第一个 Valve，这个容器里 Pipeline 中的 Valve 就都会被调用到。Basic Valve 处于 Valve 链表的末端，它是 Pipeline 中必不可少的一个 Valve，负责调用下层容器的 Pipeline 里的第一个 Valve。</p>
<p><img src="/../img/1715694618056.png" alt="1715694618056"></p>
<p>整个调用过程由连接器中的 Adapter 触发的，它会调用 Engine 的第一个 Valve：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.catalina.connector.CoyoteAdapter#service</span></span><br><span class="line"><span class="comment">// Calling the container</span></span><br><span class="line">connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);</span><br></pre></td></tr></tbody></table></figure>

<p>Wrapper 容器的最后一个 Valve 会创建一个 Filter 链，并调用 doFilter() 方法，最终会调到 Servlet 的 service 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.catalina.core.StandardWrapperValve#invoke</span></span><br><span class="line">filterChain.doFilter(request.getRequest(), response.getResponse());</span><br></pre></td></tr></tbody></table></figure>

<p>Valve 和 Filter 的区别：</p>
<ul>
<li>Valve 是 Tomcat 的私有机制，与 Tomcat 的基础架构 /API 是紧耦合的。Servlet API 是公有的标准，所有的 Web 容器包括 Jetty 都支持 Filter 机制。</li>
<li>Valve 工作在 Web 容器级别，拦截所有应用的请求；而 Servlet Filter 工作在应用级别，只能拦截某个 Web 应用的所有请求。</li>
</ul>
<h3 id="对比两种责任链模式"><a href="#对比两种责任链模式" class="headerlink" title="对比两种责任链模式"></a><strong>对比两种责任链模式</strong></h3><table>
<thead>
<tr>
<th>管道/阀门</th>
<th>过滤器链/过滤器</th>
</tr>
</thead>
<tbody><tr>
<td>管道（Pipeline）</td>
<td>过滤器链（FilterChain）</td>
</tr>
<tr>
<td>阀门（Valve）</td>
<td>过滤器（Filter）</td>
</tr>
<tr>
<td>底层实现为具有头（first）、尾（basic）指针的单向链表</td>
<td>底层实现为数组</td>
</tr>
<tr>
<td>Valve的核心方法invoke(request,response)</td>
<td>Filter核心方法doFilter(request,response,chain)</td>
</tr>
<tr>
<td>pipeline.getFirst().invoke(request,response)</td>
<td>filterchain.doFilter(request,response)</td>
</tr>
</tbody></table>
<h2 id="4、Tomcat生命周期设计"><a href="#4、Tomcat生命周期设计" class="headerlink" title="4、Tomcat生命周期设计"></a>4、<strong>Tomcat生命周期设计</strong></h2><p>通过对Tomcat架构的分析，我们知道了Tomcat 都有哪些组件，组件之间是什么样的关系，以及 Tomcat 是怎么处理一个 HTTP 请求的。如果想让Tomcat能够对外提供服务，我们需要创建、组装并启动Tomcat组件；在服务停止的时候，我们还需要释放资源，销毁Tomcat组件，这是一个动态的过程。<strong>Tomcat 需要动态地管理这些组件的生命周期。</strong></p>
<p>在我们实际的工作中，如果你需要设计一个比较大的系统或者框架时，你同样也需要考虑这几个问题：<strong>如何统一管理组件的创建、初始化、启动、停止和销毁？如何做到代码逻辑清晰？如何方便地添加或者删除组件？如何做到组件启动和停止不遗漏、不重复？</strong></p>
<h3 id="一键式启停：LifeCycle-接口"><a href="#一键式启停：LifeCycle-接口" class="headerlink" title="一键式启停：LifeCycle 接口"></a><strong>一键式启停：LifeCycle 接口</strong></h3><p><strong>系统设计就是要找到系统的变化点和不变点</strong>。这里的不变点就是每个组件都要经历创建、初始化、启动这几个过程，这些状态以及状态的转化是不变的。而变化点是每个具体组件的初始化方法，也就是启动方法是不一样的。因此，<strong>我们把不变点抽象出来成为一个接口，这个接口跟生命周期有关，叫作 LifeCycle</strong>。LifeCycle 接口里应该定义这么几个方法：init()、start()、stop() 和 destroy()，每个具体的组件去实现这些方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lifecycle</span> {</span><br><span class="line">    <span class="comment">/** 第1类：针对监听器 **/</span></span><br><span class="line">    <span class="comment">// 添加监听器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span>;</span><br><span class="line">    <span class="comment">// 获取所有监听器</span></span><br><span class="line">    <span class="keyword">public</span> LifecycleListener[] findLifecycleListeners();</span><br><span class="line">    <span class="comment">// 移除某个监听器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeLifecycleListener</span><span class="params">(LifecycleListener listener)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 第2类：针对控制流程 **/</span></span><br><span class="line">    <span class="comment">// 初始化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException;</span><br><span class="line">    <span class="comment">// 启动方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException;</span><br><span class="line">    <span class="comment">// 停止方法，和start对应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException;</span><br><span class="line">    <span class="comment">// 销毁方法，和init对应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 第3类：针对状态 **/</span></span><br><span class="line">    <span class="comment">// 获取生命周期状态</span></span><br><span class="line">    <span class="keyword">public</span> LifecycleState <span class="title function_">getState</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取字符串类型的生命周期状态</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStateName</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在父组件的 init() 方法里需要创建子组件并调用子组件的 init() 方法。同样，在父组件的 start() 方法里也需要调用子组件的 start() 方法，因此调用者可以无差别的调用各组件的 init() 方法和 start() 方法，这就是<strong>组合模式</strong>的使用，并且只要调用最顶层组件，也就是 Server 组件的 init() 和 start() 方法，整个 Tomcat 就被启动起来了。</p>
<h3 id="可扩展性：LifeCycle-事件"><a href="#可扩展性：LifeCycle-事件" class="headerlink" title="可扩展性：LifeCycle 事件"></a><strong>可扩展性：LifeCycle 事件</strong></h3><p>因为各个组件 init() 和 start() 方法的具体实现是复杂多变的，比如在 Host 容器的启动方法里需要扫描 webapps 目录下的 Web 应用，创建相应的 Context 容器，如果将来需要增加新的逻辑，直接修改 start() 方法？这样会违反开闭原则，那如何解决这个问题呢？<strong>开闭原则说的是为了扩展系统的功能，你不能直接修改系统中已有的类，但是你可以定义新的类。</strong></p>
<p>组件的 init() 和 start() 调用是由它的父组件的状态变化触发的，上层组件的初始化会触发子组件的初始化，上层组件的启动会触发子组件的启动，因此我们把组件的生命周期定义成一个个状态，把状态的转变看作是一个事件。而事件是有监听器的，在监听器里可以实现一些逻辑，并且监听器也可以方便的添加和删除，这就是典型的<strong>观察者模式。</strong></p>
<p>具体来说就是在 LifeCycle 接口里加入两个方法：添加监听器和删除监听器。</p>
<p><img src="/../img/1715694738086.png" alt="1715694738086"></p>
<p>我们还需要定义一个 Enum 来表示组件有哪些状态，以及处在什么状态会触发什么样的事件。</p>
<p><img src="/../img/1715694747795.png" alt="1715694747795"></p>
<p>组件生命周期状态变化如下：</p>
<p><img src="/../img/1715694760498.png" alt="1715694760498"></p>
<h3 id="重用性：LifeCycleBase-抽象基类"><a href="#重用性：LifeCycleBase-抽象基类" class="headerlink" title="重用性：LifeCycleBase 抽象基类"></a><strong>重用性：LifeCycleBase 抽象基类</strong></h3><p>有了接口，我们就要用类去实现接口。一般来说实现类不止一个，不同的类在实现接口时往往会有一些相同的逻辑，如果让各个子类都去实现一遍，就会有重复代码。那子类如何重用这部分逻辑呢？其实就是定义一个基类来实现共同的逻辑，然后让各个子类去继承它，就达到了重用的目的。而基类中往往会定义一些抽象方法，所谓的抽象方法就是说基类不会去实现这些方法，而是调用这些方法来实现骨架逻辑。抽象方法是留给各个子类去实现的，并且子类必须实现，否则无法实例化。</p>
<p><strong>Tomcat 定义一个基类 LifeCycleBase 来实现 LifeCycle 接口，把一些公共的逻辑放到基类中去，比如生命状态的转变与维护、生命周期事件的触发以及监听器的添加和删除等，而子类就负责实现自己的初始化、启动和停止等方法。</strong>为了避免跟基类中的方法同名，我们把具体子类的实现方法改个名字，在后面加上 Internal，叫 initInternal()、startInternal() 等。</p>
<p><img src="/../img/1715694781870.png" alt="1715694781870"></p>
<p>LifeCycleBase 实现了 LifeCycle 接口中所有的方法，还定义了相应的抽象方法交给具体子类去实现，这是典型的<strong>模板设计模式（骨架抽象类和模板方法）。</strong></p>
<p>LifeCycleBase 的 init() 方法实现：</p>
<p><img src="/../img/1715694799895.png" alt="1715694799895"></p>
<p><strong>思考：是什么时候、谁把监听器注册进来的呢？</strong></p>
<ul>
<li><p>Tomcat 自定义了一些监听器，这些监听器是父组件在创建子组件的过程中注册到子组件的。比如 MemoryLeakTrackingListener监听器，用来检测 Context 容器中的内存泄漏，这个监听器是 Host 容器在创建 Context 容器时注册到 Context 中的。</p>
</li>
<li><p>我们还可以在 server.xml 中定义自己的监听器，Tomcat 在启动时会解析 server.xml，创建监听器并注册到容器组件。</p>
</li>
</ul>
<h3 id="生命周期总体类图"><a href="#生命周期总体类图" class="headerlink" title="生命周期总体类图"></a><strong>生命周期总体类图</strong></h3><p><img src="/../img/1715694815892.png" alt="1715694815892"></p>
<p>StandardServer、StandardService 是 Server 和 Service 组件的具体实现类，它们都继承了 LifeCycleBase。StandardEngine、StandardHost、StandardContext 和 StandardWrapper 是相应容器组件的具体实现类，因为它们都是容器，所以继承了 ContainerBase 抽象基类，而 ContainerBase 实现了 Container 接口，也继承了 LifeCycleBase 类，它们的生命周期管理接口和功能接口是分开的，这也符合设计中<strong>接口分离的原则</strong>。</p>
<p>Tomcat 为了实现一键式启停以及优雅的生命周期管理，并考虑到了可扩展性和可重用性，将面向对象思想和设计模式发挥到了极致，分别运用了<strong>组合模式、观察者模式、骨架抽象类和模板方法。如果你需要维护一堆具有父子关系的实体，可以考虑使用组合模式。</strong>观察者模式听起来“高大上”，其实就是当一个事件发生后，需要执行一连串更新操作。传统的实现方式是在事件响应代码里直接加更新逻辑，当更新逻辑加多了之后，代码会变得臃肿，并且这种方式是紧耦合的、侵入式的。<strong>观察者模式实现了低耦合、非侵入式的通知与更新机制。模板方法在抽象基类中经常用到，用来实现通用逻辑。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Radish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/05/14/Tomcat(%E4%B8%80)-Tomcat%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E8%AE%BE%E8%AE%A1%E7%B2%BE%E9%AB%93%E5%88%86%E6%9E%90/">http://example.com/2024/05/14/Tomcat(%E4%B8%80)-Tomcat%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E8%AE%BE%E8%AE%A1%E7%B2%BE%E9%AB%93%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">萝卜的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Tomcat/">Tomcat</a></div><div class="post_share"><div class="social-share" data-image="/../img/jvm.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/05/14/Java%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="Java开发面试题总结"><img class="cover" src="/../img/jvm.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java开发面试题总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/14/Java%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="Java开发面试题总结"><img class="cover" src="/../img/jvm.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-14</div><div class="title">Java开发面试题总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">Radish</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">愿内心深处的懦弱 不再将我吞噬</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Tomcat%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">一、Tomcat介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Tomcat%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">1、Tomcat介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Tomcat%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">2、Tomcat目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81web%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">3、web应用部署的三种方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Tomcat%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">二、Tomcat整体架构分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Tomcat%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">2.1.</span> <span class="toc-text">1、Tomcat架构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Tomcat%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.2.</span> <span class="toc-text">2、Tomcat核心组件详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Server-%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">Server 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">Service组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%99%A8Connector%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.3.</span> <span class="toc-text">连接器Connector组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8Container%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.4.</span> <span class="toc-text">容器Container组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%BB%93%E5%90%88Server-xml%E7%90%86%E8%A7%A3Tomcat%E6%9E%B6%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">3、结合Server.xml理解Tomcat架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E8%AF%B7%E6%B1%82%E5%AE%9A%E4%BD%8D-Servlet-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">4、请求定位 Servlet 的过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Tomcat%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%B2%BE%E9%AB%93%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">三、Tomcat架构设计精髓分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Connector%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.</span> <span class="toc-text">1、Connector高内聚低耦合设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.2.</span> <span class="toc-text">2、父子容器组合模式设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Pipeline-Valve-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.3.</span> <span class="toc-text">3、Pipeline-Valve 责任链模式设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vavle%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.3.1.</span> <span class="toc-text">Vavle接口设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pipline%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.3.2.</span> <span class="toc-text">Pipline接口设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E4%B8%A4%E7%A7%8D%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.3.</span> <span class="toc-text">对比两种责任链模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Tomcat%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.4.</span> <span class="toc-text">4、Tomcat生命周期设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%94%AE%E5%BC%8F%E5%90%AF%E5%81%9C%EF%BC%9ALifeCycle-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.4.1.</span> <span class="toc-text">一键式启停：LifeCycle 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%EF%BC%9ALifeCycle-%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.4.2.</span> <span class="toc-text">可扩展性：LifeCycle 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%94%A8%E6%80%A7%EF%BC%9ALifeCycleBase-%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-number">3.4.3.</span> <span class="toc-text">重用性：LifeCycleBase 抽象基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%80%BB%E4%BD%93%E7%B1%BB%E5%9B%BE"><span class="toc-number">3.4.4.</span> <span class="toc-text">生命周期总体类图</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/14/Tomcat(%E4%B8%80)-Tomcat%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E8%AE%BE%E8%AE%A1%E7%B2%BE%E9%AB%93%E5%88%86%E6%9E%90/" title="Tomcat(一)——Tomcat整体架构及其设计精髓分析"><img src="/../img/jvm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Tomcat(一)——Tomcat整体架构及其设计精髓分析"></a><div class="content"><a class="title" href="/2024/05/14/Tomcat(%E4%B8%80)-Tomcat%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E8%AE%BE%E8%AE%A1%E7%B2%BE%E9%AB%93%E5%88%86%E6%9E%90/" title="Tomcat(一)——Tomcat整体架构及其设计精髓分析">Tomcat(一)——Tomcat整体架构及其设计精髓分析</a><time datetime="2024-05-14T13:06:00.000Z" title="发表于 2024-05-14 21:06:00">2024-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/14/Java%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="Java开发面试题总结"><img src="/../img/jvm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java开发面试题总结"></a><div class="content"><a class="title" href="/2024/05/14/Java%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="Java开发面试题总结">Java开发面试题总结</a><time datetime="2024-05-14T13:06:00.000Z" title="发表于 2024-05-14 21:06:00">2024-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E5%85%AB)%E2%80%94%E2%80%94%E8%AE%A9Java%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E7%9A%84JIT%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/" title="深入理解JVM(八)——让Java性能提升的JIT深度剖析"><img src="/../img/jvm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解JVM(八)——让Java性能提升的JIT深度剖析"></a><div class="content"><a class="title" href="/2024/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E5%85%AB)%E2%80%94%E2%80%94%E8%AE%A9Java%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E7%9A%84JIT%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/" title="深入理解JVM(八)——让Java性能提升的JIT深度剖析">深入理解JVM(八)——让Java性能提升的JIT深度剖析</a><time datetime="2024-05-13T13:22:00.000Z" title="发表于 2024-05-13 21:22:00">2024-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E4%B8%83)%E2%80%94%E2%80%94%E4%B8%BAJava%E5%BC%80%E7%96%86%E6%8B%93%E5%9C%9F%E7%9A%84ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%20-%20%E5%89%AF%E6%9C%AC/" title="深入理解JVM(七)——为Java开疆拓土的ZGC深度剖析"><img src="/../img/jvm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解JVM(七)——为Java开疆拓土的ZGC深度剖析"></a><div class="content"><a class="title" href="/2024/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E4%B8%83)%E2%80%94%E2%80%94%E4%B8%BAJava%E5%BC%80%E7%96%86%E6%8B%93%E5%9C%9F%E7%9A%84ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%20-%20%E5%89%AF%E6%9C%AC/" title="深入理解JVM(七)——为Java开疆拓土的ZGC深度剖析">深入理解JVM(七)——为Java开疆拓土的ZGC深度剖析</a><time datetime="2024-05-13T13:10:00.000Z" title="发表于 2024-05-13 21:10:00">2024-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E5%85%AD)%E2%80%94%E2%80%94JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/" title="深入理解JVM(六)——JVM调优实战及常量池详解"><img src="/../img/jvm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解JVM(六)——JVM调优实战及常量池详解"></a><div class="content"><a class="title" href="/2024/05/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E5%85%AD)%E2%80%94%E2%80%94JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/" title="深入理解JVM(六)——JVM调优实战及常量池详解">深入理解JVM(六)——JVM调优实战及常量池详解</a><time datetime="2024-05-10T13:43:00.000Z" title="发表于 2024-05-10 21:43:00">2024-05-10</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2023 - 2024 By Radish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>